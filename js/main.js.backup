/**
 * Beam Path Optimizer - Main Application Entry Point
 */

import { Component, ComponentType, ComponentNames } from './models/Component.js';
import { BeamSegment, BeamPath } from './models/BeamPath.js';
import { Store, actions, createInitialState, APP_VERSION, needsMigration } from './state.js';
import { Renderer } from './render/Renderer.js';
import { ResultsGraph } from './render/ResultsGraph.js';
import { Optimizer, OptimizerState } from './optimization/Optimizer.js';
import * as BeamPhysics from './physics/BeamPhysics.js';

/**
 * Main Application Class
 */
class BeamPathOptimizerApp {
    constructor() {
        // Initialize store
        this.store = new Store(createInitialState());

        // Get canvas and initialize renderer
        this.canvas = document.getElementById('main-canvas');
        this.renderer = new Renderer(this.canvas);

        // Interaction state
        this.isDragging = false;
        this.dragStart = null;
        this.dragComponent = null;
        this.dragZone = null;          // Zone being dragged
        this.dragZoneOffset = null;    // Offset from zone top-left to click point
        this.isPanning = false;
        this.panStart = null;
        this.isSelectionBoxDragging = false;

        // Optimizer
        this.optimizer = new Optimizer();
        this.originalPositionsBeforeOptimize = null;
        this.selectionBoxStart = null;

        // Results View state
        this.resultsGraph = null;
        this.isResultsViewOpen = false;
        this.previewSnapshot = null;
        this.isSplitScreenMode = false;

        // Drag from palette state
        this.isDraggingFromPalette = false;
        this.dragComponentType = null;
        this.dragPreviewElement = null;
        this.paletteMouseStart = null;

        // Bind methods
        this.render = this.render.bind(this);
        this.handleMouseDown = this.handleMouseDown.bind(this);
        this.handleMouseMove = this.handleMouseMove.bind(this);
        this.handleMouseUp = this.handleMouseUp.bind(this);
        this.handleWheel = this.handleWheel.bind(this);
        this.handleKeyDown = this.handleKeyDown.bind(this);

        // Initialize
        this.setupEventListeners();
        this.setupUIBindings();

        // Subscribe to state changes
        this.store.subscribe(() => {
            this.render();
            this.updateUI();
        });

        // Initial render
        this.render();
        this.updateUI();

        // Set version display
        const versionEl = document.getElementById('app-version');
        if (versionEl) {
            versionEl.textContent = APP_VERSION.toString();
        }

        // Initialize file name input
        const fileNameInput = document.getElementById('file-name-input');
        if (fileNameInput) {
            const state = this.store.getState();
            fileNameInput.value = state.document.name || 'beam-path';

            // Sync file name input changes to state
            fileNameInput.addEventListener('input', (e) => {
                const newName = e.target.value.trim() || 'beam-path';
                this.store.dispatch(actions.updateDocumentName(newName));
            });
        }

        console.log('Beam Path Optimizer initialized', APP_VERSION.toString());
    }

    /**
     * Set up canvas event listeners
     */
    setupEventListeners() {
        this.canvas.addEventListener('mousedown', this.handleMouseDown);
        this.canvas.addEventListener('mousemove', this.handleMouseMove);
        this.canvas.addEventListener('mouseup', this.handleMouseUp);
        this.canvas.addEventListener('mouseleave', this.handleMouseUp);
        this.canvas.addEventListener('wheel', this.handleWheel, { passive: false });
        document.addEventListener('keydown', this.handleKeyDown);
    }

    /**
     * Set up UI button and input bindings
     */
    setupUIBindings() {
        // Tool buttons
        document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => {
            btn.addEventListener('click', () => {
                this.setTool(btn.dataset.tool);
            });
        });

        // Component buttons (drag-and-drop from palette)
        document.querySelectorAll('.component-btn[data-component]').forEach(btn => {
            btn.addEventListener('mousedown', (e) => {
                e.preventDefault();
                this.paletteMouseStart = { x: e.clientX, y: e.clientY };
                this.dragComponentType = btn.dataset.component;
            });
        });

        // Document-level mouse handlers for palette drag
        document.addEventListener('mousemove', (e) => this.handlePaletteDrag(e));
        document.addEventListener('mouseup', (e) => this.handlePaletteDrop(e));

        // Toolbar buttons
        document.getElementById('btn-new')?.addEventListener('click', () => this.newDocument());
        document.getElementById('btn-open')?.addEventListener('click', () => this.openDocument());
        document.getElementById('btn-save')?.addEventListener('click', () => this.saveDocument());
        document.getElementById('btn-undo')?.addEventListener('click', () => this.undo());
        document.getElementById('btn-redo')?.addEventListener('click', () => this.redo());

        // Workspace size inputs
        document.getElementById('workspace-width')?.addEventListener('change', (e) => {
            const width = parseInt(e.target.value) || 600;
            const height = parseInt(document.getElementById('workspace-height').value) || 600;
            this.store.dispatch(actions.setWorkspaceSize(width, height));
        });
        document.getElementById('workspace-height')?.addEventListener('change', (e) => {
            const width = parseInt(document.getElementById('workspace-width').value) || 600;
            const height = parseInt(e.target.value) || 600;
            this.store.dispatch(actions.setWorkspaceSize(width, height));
        });

        // Zoom controls
        document.getElementById('zoom-in')?.addEventListener('click', () => this.zoom(1.2));
        document.getElementById('zoom-out')?.addEventListener('click', () => this.zoom(0.8));
        document.getElementById('zoom-fit')?.addEventListener('click', () => this.zoomFit());

        // Grid controls
        this.setupGridControls();

        // Label visibility toggle
        document.getElementById('btn-toggle-labels')?.addEventListener('click', () => {
            this.store.dispatch(actions.toggleLabels());
        });

        // Laser On toggle
        document.getElementById('auto-propagate-beams')?.addEventListener('change', (e) => {
            this.store.dispatch(actions.toggleAutoPropagate());
            if (e.target.checked) {
                // Turning laser on - propagate all beams from sources
                this.propagateAllBeams();
            } else {
                // Turning laser off - remove all beams
                this.clearAllBeams();
            }
        });

        // Panel resize handle
        this.setupPanelResize();

        // Panel text size control
        this.setupPanelTextSize();

        // Settings modal
        this.setupSettingsModal();

        // Wavelength controls
        this.setupWavelengthControls();

        // Property panel inputs
        this.setupPropertyInputs();

        // Delete button
        document.getElementById('btn-delete')?.addEventListener('click', () => this.deleteSelected());
        document.getElementById('btn-duplicate')?.addEventListener('click', () => this.duplicateSelected());

        // Path length constraint button
        document.getElementById('btn-add-path-constraint')?.addEventListener('click', () => {
            const state = this.store.getState();
            const selectedIds = state.ui.selection.selectedIds;

            if (selectedIds.length === 2) {
                // Two components selected - create constraint directly
                this.createPathLengthConstraint(selectedIds[0], selectedIds[1]);
            } else if (selectedIds.length === 1) {
                // One component selected - show selection dialog (future enhancement)
                this.showToast('Select two lens or beam splitter components to create a path length constraint', 'info');
            } else {
                this.showToast('Please select two lens or beam splitter components', 'warning');
            }
        });

        // Zone property inputs
        this.setupZonePropertyInputs();

        // Segment property inputs
        this.setupSegmentPropertyInputs();

        // Optimizer controls
        this.setupOptimizerControls();
    }

    /**
     * Set up property panel input bindings
     */
    setupPropertyInputs() {
        const inputs = {
            'prop-name': 'name',
            'prop-label-position': 'labelPosition',
            'prop-label-visible': 'labelVisible',
            'prop-x': 'position.x',
            'prop-y': 'position.y',
            'prop-angle': 'angle',
            'prop-angle-slider': 'angle',
            'prop-mass': 'mass',
            'prop-width': 'size.width',
            'prop-height': 'size.height',
            'prop-fixed': 'isFixed',
            'prop-angle-fixed': 'isAngleFixed'
        };

        Object.entries(inputs).forEach(([inputId, propPath]) => {
            const input = document.getElementById(inputId);
            if (!input) return;

            input.addEventListener('change', () => {
                const state = this.store.getState();
                const selectedId = state.ui.selection.selectedIds[0];
                if (!selectedId) return;

                const component = state.components.get(selectedId);
                if (!component) return;

                let value = input.type === 'checkbox' ? input.checked :
                           input.type === 'range' ? parseFloat(input.value) :
                           input.type === 'number' ? parseFloat(input.value) : input.value;

                // Clamp angle to 0-180Â° range
                if (propPath === 'angle') {
                    value = Math.max(0, Math.min(180, value));
                }

                // Apply angle constraints if updating angle and allowAnyAngle is false
                if (propPath === 'angle' && !component.allowAnyAngle) {
                    value = BeamPhysics.snapAngleToValid(
                        value,
                        component.type,
                        component.isShallowAngle,
                        component.shallowAngle
                    );
                    // Update the input to show the snapped value
                    input.value = value;
                    document.getElementById('prop-angle').value = value;
                    document.getElementById('prop-angle-slider').value = value;
                }

                // Handle nested properties
                const updates = {};
                if (propPath.includes('.')) {
                    const [parent, child] = propPath.split('.');
                    updates[parent] = { ...component[parent], [child]: value };
                } else {
                    updates[propPath] = value;
                }

                this.store.dispatch(actions.updateComponent(selectedId, updates));
            });

            // Sync angle slider and input
            if (inputId === 'prop-angle-slider') {
                input.addEventListener('input', () => {
                    document.getElementById('prop-angle').value = input.value;
                });
            }
            if (inputId === 'prop-angle') {
                input.addEventListener('input', () => {
                    document.getElementById('prop-angle-slider').value = input.value;
                });
            }
        });

        // Label position and visibility controls (explicit handlers)
        const labelPositionSelect = document.getElementById('prop-label-position');
        if (labelPositionSelect) {
            labelPositionSelect.addEventListener('change', (e) => {
                const state = this.store.getState();
                const selectedId = state.ui.selection.selectedIds[0];
                if (selectedId) {
                    this.store.dispatch(actions.updateComponent(selectedId, { labelPosition: e.target.value }));
                }
            });
        }

        const labelVisibleCheckbox = document.getElementById('prop-label-visible');
        if (labelVisibleCheckbox) {
            labelVisibleCheckbox.addEventListener('change', (e) => {
                const state = this.store.getState();
                const selectedId = state.ui.selection.selectedIds[0];
                if (selectedId) {
                    this.store.dispatch(actions.updateComponent(selectedId, { labelVisible: e.target.checked }));
                }
            });
        }

        // Label background color
        const labelBgColorInput = document.getElementById('prop-label-bg-color');
        if (labelBgColorInput) {
            labelBgColorInput.addEventListener('change', (e) => {
                const state = this.store.getState();
                const selectedId = state.ui.selection.selectedIds[0];
                if (selectedId) {
                    this.store.dispatch(actions.updateComponent(selectedId, { labelBackgroundColor: e.target.value }));
                }
            });
        }

        // Label color auto button
        const labelColorAutoBtn = document.getElementById('btn-label-color-auto');
        if (labelColorAutoBtn) {
            labelColorAutoBtn.addEventListener('click', () => {
                const state = this.store.getState();
                const selectedId = state.ui.selection.selectedIds[0];
                if (selectedId) {
                    this.store.dispatch(actions.updateComponent(selectedId, { labelBackgroundColor: 'auto' }));
                }
            });
        }

        // Reflectance slider
        const reflectanceSlider = document.getElementById('prop-reflectance-slider');
        if (reflectanceSlider) {
            reflectanceSlider.addEventListener('input', () => {
                document.getElementById('prop-reflectance-value').textContent = reflectanceSlider.value;
            });
            reflectanceSlider.addEventListener('change', () => {
                const state = this.store.getState();
                const selectedId = state.ui.selection.selectedIds[0];
                if (!selectedId) return;

                const reflectance = parseFloat(reflectanceSlider.value) / 100;
                this.store.dispatch(actions.updateComponent(selectedId, {
                    reflectance,
                    transmittance: 1 - reflectance
                }));

                // Re-propagate beams if auto-propagate is enabled
                if (state.ui.autoPropagate) {
                    this.clearAllBeams();
                    this.propagateAllBeams();
                    this.render();
                }
            });
        }

        // Mount zone controls
        const mountEnabledCheckbox = document.getElementById('prop-mount-enabled');
        const mountDetailsControls = document.getElementById('mount-details-controls');

        if (mountEnabledCheckbox) {
            mountEnabledCheckbox.addEventListener('change', () => {
                const state = this.store.getState();
                const selectedId = state.ui.selection.selectedIds[0];
                if (!selectedId) return;

                const enabled = mountEnabledCheckbox.checked;
                this.store.dispatch(actions.updateComponent(selectedId, {
                    mountZone: { enabled }
                }));

                // Show/hide detail controls
                if (mountDetailsControls) {
                    mountDetailsControls.style.display = enabled ? 'flex' : 'none';
                }
            });
        }

        // Mount zone padding X
        document.getElementById('prop-mount-padding-x')?.addEventListener('change', (e) => {
            const state = this.store.getState();
            const selectedId = state.ui.selection.selectedIds[0];
            if (!selectedId) return;

            const paddingX = parseFloat(e.target.value) || 10;
            this.store.dispatch(actions.updateComponent(selectedId, {
                mountZone: { paddingX }
            }));
        });

        // Mount zone padding Y
        document.getElementById('prop-mount-padding-y')?.addEventListener('change', (e) => {
            const state = this.store.getState();
            const selectedId = state.ui.selection.selectedIds[0];
            if (!selectedId) return;

            const paddingY = parseFloat(e.target.value) || 10;
            this.store.dispatch(actions.updateComponent(selectedId, {
                mountZone: { paddingY }
            }));
        });

        // Mount zone offset X
        document.getElementById('prop-mount-offset-x')?.addEventListener('change', (e) => {
            const state = this.store.getState();
            const selectedId = state.ui.selection.selectedIds[0];
            if (!selectedId) return;

            const offsetX = parseFloat(e.target.value) || 0;
            this.store.dispatch(actions.updateComponent(selectedId, {
                mountZone: { offsetX }
            }));
        });

        // Mount zone offset Y
        document.getElementById('prop-mount-offset-y')?.addEventListener('change', (e) => {
            const state = this.store.getState();
            const selectedId = state.ui.selection.selectedIds[0];
            if (!selectedId) return;

            const offsetY = parseFloat(e.target.value) || 0;
            this.store.dispatch(actions.updateComponent(selectedId, {
                mountZone: { offsetY }
            }));
        });

        // === Beam Physics Controls ===
        this.setupBeamPhysicsControls();
    }

    /**
     * Set up beam physics property controls
     */
    setupBeamPhysicsControls() {
        // Emit light toggle (for sources)
        document.getElementById('prop-emit-light')?.addEventListener('change', (e) => {
            const state = this.store.getState();
            const selectedId = state.ui.selection.selectedIds[0];
            if (!selectedId) return;

            this.store.dispatch(actions.updateComponent(selectedId, {
                emitLight: e.target.checked
            }));

            // Re-propagate beams if auto-propagate is enabled
            if (state.ui.autoPropagate) {
                this.clearAllBeams();
                this.propagateAllBeams();
                this.render();
            }
        });

        // Shallow angle mode toggle
        const shallowEnabledCheckbox = document.getElementById('prop-shallow-enabled');
        const shallowAngleControls = document.getElementById('shallow-angle-controls');

        shallowEnabledCheckbox?.addEventListener('change', () => {
            const state = this.store.getState();
            const selectedId = state.ui.selection.selectedIds[0];
            if (!selectedId) return;

            const isShallowAngle = shallowEnabledCheckbox.checked;
            this.store.dispatch(actions.updateComponent(selectedId, {
                isShallowAngle,
                snapToGrid: !isShallowAngle  // Auto-disable grid snap for shallow angle
            }));

            if (shallowAngleControls) {
                shallowAngleControls.style.display = isShallowAngle ? 'block' : 'none';
            }

            // Update snap grid checkbox
            document.getElementById('prop-snap-grid').checked = !isShallowAngle;
        });

        // Shallow angle value
        document.getElementById('prop-shallow-angle')?.addEventListener('change', (e) => {
            const state = this.store.getState();
            const selectedId = state.ui.selection.selectedIds[0];
            if (!selectedId) return;

            const shallowAngle = parseFloat(e.target.value) || 5;
            this.store.dispatch(actions.updateComponent(selectedId, { shallowAngle }));
        });

        // Grid snap toggle
        document.getElementById('prop-snap-grid')?.addEventListener('change', (e) => {
            const state = this.store.getState();
            const selectedId = state.ui.selection.selectedIds[0];
            if (!selectedId) return;

            this.store.dispatch(actions.updateComponent(selectedId, {
                snapToGrid: e.target.checked
            }));
        });

        // Allow any angle toggle
        document.getElementById('prop-allow-any-angle')?.addEventListener('change', (e) => {
            const state = this.store.getState();
            const selectedId = state.ui.selection.selectedIds[0];
            if (!selectedId) return;

            this.store.dispatch(actions.updateComponent(selectedId, {
                allowAnyAngle: e.target.checked
            }));
        });

    }

    /**
     * Set up grid controls
     */
    setupGridControls() {
        const btnGridSettings = document.getElementById('btn-grid-settings');
        const gridModal = document.getElementById('grid-modal');
        const closeModal = document.getElementById('close-grid-modal');

        // Open modal
        btnGridSettings?.addEventListener('click', () => {
            this.syncGridModalFromState();
            gridModal?.classList.remove('hidden');
        });

        // Close modal
        closeModal?.addEventListener('click', () => {
            gridModal?.classList.add('hidden');
        });

        // Close on backdrop click
        gridModal?.addEventListener('click', (e) => {
            if (e.target === gridModal) {
                gridModal.classList.add('hidden');
            }
        });

        // Grid visible toggle
        const gridVisibleCheckbox = document.getElementById('grid-visible-modal');
        gridVisibleCheckbox?.addEventListener('change', (e) => {
            this.store.dispatch(actions.setGridSettings({ visible: e.target.checked }));
        });

        // Grid enabled toggle
        const gridEnabledCheckbox = document.getElementById('grid-enabled-modal');
        gridEnabledCheckbox?.addEventListener('change', (e) => {
            this.store.dispatch(actions.setGridSettings({ enabled: e.target.checked }));
        });

        // Grid size slider
        const gridSizeSlider = document.getElementById('grid-size-slider-modal');
        const gridSizeInput = document.getElementById('grid-size-input-modal');
        const gridSizeValue = document.getElementById('grid-size-value-modal');

        gridSizeSlider?.addEventListener('input', (e) => {
            const size = parseInt(e.target.value, 10);
            if (gridSizeInput) gridSizeInput.value = size;
            if (gridSizeValue) gridSizeValue.textContent = size;
            this.store.dispatch(actions.setGridSettings({ size }));
        });

        // Grid size input
        gridSizeInput?.addEventListener('change', (e) => {
            let size = parseInt(e.target.value, 10);
            size = Math.max(1, Math.min(50, size)); // Clamp to 1-50
            e.target.value = size;
            if (gridSizeSlider) gridSizeSlider.value = size;
            if (gridSizeValue) gridSizeValue.textContent = size;
            this.store.dispatch(actions.setGridSettings({ size }));
        });
    }

    syncGridModalFromState() {
        const grid = this.store.getState().grid;
        const gridVisibleCheckbox = document.getElementById('grid-visible-modal');
        const gridEnabledCheckbox = document.getElementById('grid-enabled-modal');
        const gridSizeSlider = document.getElementById('grid-size-slider-modal');
        const gridSizeInput = document.getElementById('grid-size-input-modal');
        const gridSizeValue = document.getElementById('grid-size-value-modal');

        if (gridVisibleCheckbox) gridVisibleCheckbox.checked = grid.visible;
        if (gridEnabledCheckbox) gridEnabledCheckbox.checked = grid.enabled;
        if (gridSizeSlider) gridSizeSlider.value = grid.size;
        if (gridSizeInput) gridSizeInput.value = grid.size;
        if (gridSizeValue) gridSizeValue.textContent = grid.size;
    }

    /**
     * Set up panel resize handle
     */
    setupPanelResize() {
        const handle = document.getElementById('panel-resize-handle');
        const panel = document.getElementById('properties-panel');
        if (!handle || !panel) return;

        let isResizing = false;
        let startX = 0;
        let startWidth = 0;

        // Load saved width from localStorage
        const savedWidth = localStorage.getItem('panelWidth');
        if (savedWidth) {
            const width = parseInt(savedWidth, 10);
            if (width >= 180 && width <= 400) {
                panel.style.width = `${width}px`;
            }
        }

        handle.addEventListener('mousedown', (e) => {
            isResizing = true;
            startX = e.clientX;
            startWidth = panel.offsetWidth;
            handle.classList.add('resizing');
            document.body.classList.add('resizing-panel');
            e.preventDefault();
        });

        document.addEventListener('mousemove', (e) => {
            if (!isResizing) return;

            // Calculate new width (inverted because we're resizing from left edge of panel)
            const deltaX = startX - e.clientX;
            let newWidth = startWidth + deltaX;

            // Clamp to min/max
            newWidth = Math.max(180, Math.min(400, newWidth));

            panel.style.width = `${newWidth}px`;
        });

        document.addEventListener('mouseup', () => {
            if (isResizing) {
                isResizing = false;
                handle.classList.remove('resizing');
                document.body.classList.remove('resizing-panel');

                // Save to localStorage
                localStorage.setItem('panelWidth', panel.offsetWidth);

                // Re-render canvas to adjust for new size
                this.renderer.handleResize();
                this.render();
            }
        });
    }

    /**
     * Set up panel text size control
     */
    setupPanelTextSize() {
        const slider = document.getElementById('panel-text-size');
        const valueDisplay = document.getElementById('panel-text-size-value');
        if (!slider) return;

        // Load saved value from localStorage
        const savedSize = localStorage.getItem('panelTextSize');
        if (savedSize) {
            const size = parseInt(savedSize, 10);
            if (size >= 80 && size <= 150) {
                slider.value = size;
                if (valueDisplay) valueDisplay.textContent = size;
                document.documentElement.style.setProperty('--panel-text-scale', size / 100);
            }
        }

        slider.addEventListener('input', (e) => {
            const size = parseInt(e.target.value, 10);
            if (valueDisplay) valueDisplay.textContent = size;
            document.documentElement.style.setProperty('--panel-text-scale', size / 100);
            localStorage.setItem('panelTextSize', size);
        });
    }

    /**
     * Set up settings modal
     */
    setupSettingsModal() {
        const modal = document.getElementById('settings-modal');
        const btnSettings = document.getElementById('btn-settings');
        const btnClose = document.getElementById('close-settings');
        const bgTypeRadios = document.querySelectorAll('input[name="bg-type"]');
        const bgColorInput = document.getElementById('bg-color');
        const bgColorValue = document.getElementById('bg-color-value');
        const bgImageInput = document.getElementById('bg-image');
        const btnChooseImage = document.getElementById('btn-choose-image');
        const bgImageName = document.getElementById('bg-image-name');

        // Open modal
        btnSettings?.addEventListener('click', () => {
            // Sync UI with current state
            const state = this.store.getState();
            const bg = state.background || {};

            // Set radio button
            bgTypeRadios.forEach(radio => {
                radio.checked = radio.value === (bg.type || 'color');
            });

            // Set color
            if (bgColorInput && bg.color) {
                bgColorInput.value = bg.color;
                if (bgColorValue) bgColorValue.textContent = bg.color;
            }

            // Set image name
            if (bgImageName) {
                bgImageName.textContent = bg.imagePath || 'No image selected';
            }

            modal?.classList.remove('hidden');
        });

        // Close modal
        btnClose?.addEventListener('click', () => {
            modal?.classList.add('hidden');
        });

        // Close on backdrop click
        modal?.addEventListener('click', (e) => {
            if (e.target === modal) {
                modal.classList.add('hidden');
            }
        });

        // Background type change
        bgTypeRadios.forEach(radio => {
            radio.addEventListener('change', (e) => {
                this.store.dispatch(actions.setBackground({ type: e.target.value }));
            });
        });

        // Background color change
        bgColorInput?.addEventListener('input', (e) => {
            const color = e.target.value;
            if (bgColorValue) bgColorValue.textContent = color;
            this.store.dispatch(actions.setBackground({ color }));
        });

        // Choose image button
        btnChooseImage?.addEventListener('click', () => {
            bgImageInput?.click();
        });

        // Image file selected
        bgImageInput?.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                const dataURL = event.target.result; // Store the data URL
                img.onload = () => {
                    this.store.dispatch(actions.setBackground({
                        type: 'image',
                        imagePath: file.name,
                        imageData: img,
                        imageDataURL: dataURL // Save the data URL for persistence
                    }));

                    // Update UI
                    if (bgImageName) bgImageName.textContent = file.name;

                    // Set radio to image
                    bgTypeRadios.forEach(radio => {
                        radio.checked = radio.value === 'image';
                    });
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        });

        // Opacity slider
        const bgOpacitySlider = document.getElementById('bg-opacity');
        const bgOpacityValue = document.getElementById('bg-opacity-value');
        bgOpacitySlider?.addEventListener('input', (e) => {
            const opacity = parseInt(e.target.value, 10);
            if (bgOpacityValue) bgOpacityValue.textContent = opacity;

            const state = this.store.getState();
            this.store.dispatch(actions.setBackground({
                ...state.background,
                opacity
            }));
        });

        // Sync opacity from state when modal opens
        this.store.subscribe(() => {
            const bg = this.store.getState().background;
            if (bgOpacitySlider && bg.opacity !== undefined) {
                bgOpacitySlider.value = bg.opacity;
            }
            if (bgOpacityValue && bg.opacity !== undefined) {
                bgOpacityValue.textContent = bg.opacity;
            }
        });
    }

    /**
     * Set up wavelength controls
     */
    setupWavelengthControls() {
        const wavelengthSelect = document.getElementById('active-wavelength');
        const btnManage = document.getElementById('btn-manage-wavelengths');

        // Initial population
        this.updateWavelengthDropdown();

        // Wavelength selection change
        wavelengthSelect?.addEventListener('change', (e) => {
            this.store.dispatch(actions.setActiveWavelength(e.target.value));
        });

        // Manage wavelengths button - opens modal
        btnManage?.addEventListener('click', () => {
            this.openWavelengthModal();
        });

        // Subscribe to state changes to update dropdown
        this.store.subscribe(() => {
            this.updateWavelengthDropdown();
        });
    }

    /**
     * Open wavelength management modal
     */
    openWavelengthModal() {
        const modal = document.getElementById('wavelength-modal');
        modal?.classList.remove('hidden');
        this.renderWavelengthList();

        // Close modal handlers
        document.getElementById('close-wavelength-modal')?.addEventListener('click', () => {
            modal?.classList.add('hidden');
        });

        modal?.addEventListener('click', (e) => {
            if (e.target === modal) modal.classList.add('hidden');
        });

        // Add new wavelength
        document.getElementById('btn-add-wavelength')?.addEventListener('click', () => {
            this.addNewWavelength();
        });
    }

    /**
     * Render wavelength list in modal
     */
    renderWavelengthList() {
        const list = document.getElementById('wavelength-list');
        if (!list) return;

        const wavelengths = this.store.getState().wavelengths || [];

        list.innerHTML = wavelengths.map(w => `
            <div class="wavelength-item" data-id="${w.id}">
                <div class="swatch" style="background-color: ${w.color}"></div>
                <input type="text" class="name" value="${w.name}" readonly data-id="${w.id}">
                <input type="color" class="color-picker hidden" value="${w.color}" data-id="${w.id}">
                <div class="actions">
                    <button class="edit-btn" data-id="${w.id}">Edit</button>
                    <button class="save-btn hidden" data-id="${w.id}">Save</button>
                    <button class="cancel-btn hidden" data-id="${w.id}">Cancel</button>
                    <button class="delete-btn delete" data-id="${w.id}" ${w.isPreset ? 'disabled' : ''}>Delete</button>
                </div>
            </div>
        `).join('');

        this.attachWavelengthItemHandlers();
    }

    /**
     * Attach event handlers to wavelength items
     */
    attachWavelengthItemHandlers() {
        // Edit buttons
        document.querySelectorAll('.wavelength-item .edit-btn').forEach(btn => {
            btn.addEventListener('click', () => this.editWavelength(btn.dataset.id));
        });

        // Save buttons
        document.querySelectorAll('.wavelength-item .save-btn').forEach(btn => {
            btn.addEventListener('click', () => this.saveWavelength(btn.dataset.id));
        });

        // Cancel buttons
        document.querySelectorAll('.wavelength-item .cancel-btn').forEach(btn => {
            btn.addEventListener('click', () => this.cancelEditWavelength());
        });

        // Delete buttons
        document.querySelectorAll('.wavelength-item .delete-btn').forEach(btn => {
            btn.addEventListener('click', () => this.deleteWavelength(btn.dataset.id));
        });
    }

    /**
     * Add new wavelength
     */
    addNewWavelength() {
        const nameInput = document.getElementById('new-wavelength-name');
        const colorInput = document.getElementById('new-wavelength-color');

        const name = nameInput?.value.trim();
        const color = colorInput?.value;

        if (!name) {
            this.showToast('Wavelength name required', 'warning');
            return;
        }

        this.store.dispatch(actions.addWavelength(name, color));
        this.renderWavelengthList();

        // Clear inputs
        if (nameInput) nameInput.value = '';
        if (colorInput) colorInput.value = '#ff0000';

        this.showToast(`Added wavelength: ${name}`, 'success');
    }

    /**
     * Edit wavelength - enable editing mode
     */
    editWavelength(id) {
        const item = document.querySelector(`.wavelength-item[data-id="${id}"]`);
        if (!item) return;

        const nameInput = item.querySelector('.name');
        const colorPicker = item.querySelector('.color-picker');
        const editBtn = item.querySelector('.edit-btn');
        const saveBtn = item.querySelector('.save-btn');
        const cancelBtn = item.querySelector('.cancel-btn');

        // Enable editing
        nameInput?.removeAttribute('readonly');
        colorPicker?.classList.remove('hidden');
        editBtn?.classList.add('hidden');
        saveBtn?.classList.remove('hidden');
        cancelBtn?.classList.remove('hidden');
    }

    /**
     * Save wavelength changes
     */
    saveWavelength(id) {
        const item = document.querySelector(`.wavelength-item[data-id="${id}"]`);
        if (!item) return;

        const nameInput = item.querySelector('.name');
        const colorPicker = item.querySelector('.color-picker');

        const name = nameInput?.value.trim();
        const color = colorPicker?.value;

        if (!name) {
            this.showToast('Wavelength name required', 'warning');
            return;
        }

        this.store.dispatch(actions.updateWavelength(id, { name, color }));
        this.renderWavelengthList();
        this.showToast('Wavelength updated', 'success');
    }

    /**
     * Cancel wavelength editing
     */
    cancelEditWavelength() {
        this.renderWavelengthList(); // Re-render to reset
    }

    /**
     * Delete wavelength
     */
    deleteWavelength(id) {
        const wavelengths = this.store.getState().wavelengths || [];
        const wavelength = wavelengths.find(w => w.id === id);

        if (wavelength?.isPreset) {
            this.showToast('Cannot delete preset wavelengths', 'warning');
            return;
        }

        if (confirm(`Delete wavelength "${wavelength?.name}"?`)) {
            this.store.dispatch(actions.deleteWavelength(id));
            this.renderWavelengthList();
            this.showToast('Wavelength deleted', 'success');
        }
    }

    /**
     * Update wavelength dropdown from state
     */
    updateWavelengthDropdown() {
        const select = document.getElementById('active-wavelength');
        if (!select) return;

        const state = this.store.getState();
        const wavelengths = state.wavelengths || [];
        const activeId = state.activeWavelengthId;

        // Clear and repopulate
        select.innerHTML = '';
        wavelengths.forEach(w => {
            const option = document.createElement('option');
            option.value = w.id;
            option.textContent = w.name;
            option.style.color = w.color;
            if (w.id === activeId) option.selected = true;
            select.appendChild(option);
        });
    }

    /**
     * Set up zone property input bindings
     */
    setupZonePropertyInputs() {
        // Zone name
        document.getElementById('zone-prop-name')?.addEventListener('change', (e) => {
            const state = this.store.getState();
            const zoneId = state.ui.selection.selectedZoneId;
            if (!zoneId) return;

            if (zoneId === 'mounting') {
                this.store.dispatch(actions.updateMountingZone({ name: e.target.value }));
            } else if (zoneId.startsWith('keepout:')) {
                const id = zoneId.replace('keepout:', '');
                this.store.dispatch(actions.updateKeepOutZone(id, { name: e.target.value }));
            }
        });

        // Zone position X
        document.getElementById('zone-prop-x')?.addEventListener('change', (e) => {
            const state = this.store.getState();
            const zoneId = state.ui.selection.selectedZoneId;
            if (!zoneId) return;

            const x = parseFloat(e.target.value) || 0;
            if (zoneId === 'mounting') {
                this.store.dispatch(actions.updateMountingZone({ bounds: { x } }));
            } else if (zoneId.startsWith('keepout:')) {
                const id = zoneId.replace('keepout:', '');
                const zone = state.constraints.keepOutZones.find(z => z.id === id);
                if (zone) {
                    this.store.dispatch(actions.updateKeepOutZone(id, {
                        bounds: { ...zone.bounds, x }
                    }));
                }
            }
        });

        // Zone position Y
        document.getElementById('zone-prop-y')?.addEventListener('change', (e) => {
            const state = this.store.getState();
            const zoneId = state.ui.selection.selectedZoneId;
            if (!zoneId) return;

            const y = parseFloat(e.target.value) || 0;
            if (zoneId === 'mounting') {
                this.store.dispatch(actions.updateMountingZone({ bounds: { y } }));
            } else if (zoneId.startsWith('keepout:')) {
                const id = zoneId.replace('keepout:', '');
                const zone = state.constraints.keepOutZones.find(z => z.id === id);
                if (zone) {
                    this.store.dispatch(actions.updateKeepOutZone(id, {
                        bounds: { ...zone.bounds, y }
                    }));
                }
            }
        });

        // Zone width
        document.getElementById('zone-prop-width')?.addEventListener('change', (e) => {
            const state = this.store.getState();
            const zoneId = state.ui.selection.selectedZoneId;
            if (!zoneId) return;

            const width = parseFloat(e.target.value) || 10;
            if (zoneId === 'mounting') {
                this.store.dispatch(actions.updateMountingZone({ bounds: { width } }));
            } else if (zoneId.startsWith('keepout:')) {
                const id = zoneId.replace('keepout:', '');
                const zone = state.constraints.keepOutZones.find(z => z.id === id);
                if (zone) {
                    this.store.dispatch(actions.updateKeepOutZone(id, {
                        bounds: { ...zone.bounds, width }
                    }));
                }
            }
        });

        // Zone height
        document.getElementById('zone-prop-height')?.addEventListener('change', (e) => {
            const state = this.store.getState();
            const zoneId = state.ui.selection.selectedZoneId;
            if (!zoneId) return;

            const height = parseFloat(e.target.value) || 10;
            if (zoneId === 'mounting') {
                this.store.dispatch(actions.updateMountingZone({ bounds: { height } }));
            } else if (zoneId.startsWith('keepout:')) {
                const id = zoneId.replace('keepout:', '');
                const zone = state.constraints.keepOutZones.find(z => z.id === id);
                if (zone) {
                    this.store.dispatch(actions.updateKeepOutZone(id, {
                        bounds: { ...zone.bounds, height }
                    }));
                }
            }
        });

        // Zone active (keep-out zones only)
        document.getElementById('zone-prop-active')?.addEventListener('change', (e) => {
            const state = this.store.getState();
            const zoneId = state.ui.selection.selectedZoneId;
            if (!zoneId || !zoneId.startsWith('keepout:')) return;

            const id = zoneId.replace('keepout:', '');
            this.store.dispatch(actions.updateKeepOutZone(id, { isActive: e.target.checked }));
        });

        // Delete zone button
        document.getElementById('btn-delete-zone')?.addEventListener('click', () => {
            this.deleteSelected();
        });
    }

    /**
     * Set up segment property input bindings
     */
    setupSegmentPropertyInputs() {
        // Add wavelength to segment
        document.getElementById('btn-add-segment-wavelength')?.addEventListener('click', () => {
            const state = this.store.getState();
            const selectedSegmentIds = state.ui.selection.selectedSegmentIds || [];
            if (selectedSegmentIds.length === 0) return;

            const selectEl = document.getElementById('segment-wavelength-select');
            const wavelengthId = selectEl?.value;
            if (!wavelengthId) return;

            // Add wavelength to all selected segments
            selectedSegmentIds.forEach(segmentId => {
                const segment = state.beamPath.segments.get(segmentId);
                if (segment) {
                    const currentWavelengthIds = segment.wavelengthIds || [];
                    if (!currentWavelengthIds.includes(wavelengthId)) {
                        const newWavelengthIds = [...currentWavelengthIds, wavelengthId];
                        this.store.dispatch(actions.updateSegmentWavelengths(segmentId, newWavelengthIds));
                    }
                }
            });

            // Reset dropdown
            selectEl.value = '';
        });

        // Delete segment button
        document.getElementById('btn-delete-segment')?.addEventListener('click', () => {
            this.deleteSelected();
        });
    }

    /**
     * Set up optimizer control bindings
     */
    setupOptimizerControls() {
        // Weight sliders
        ['weight-com', 'weight-footprint', 'weight-path'].forEach(id => {
            const slider = document.getElementById(id);
            if (slider) {
                slider.addEventListener('input', () => {
                    slider.nextElementSibling.textContent = slider.value + '%';
                });
            }
        });

        // Start optimization button
        document.getElementById('btn-optimize')?.addEventListener('click', () => {
            this.startOptimization();
        });

        // Pause button
        document.getElementById('btn-pause-optimize')?.addEventListener('click', () => {
            this.pauseOptimization();
        });

        // Resume button
        document.getElementById('btn-resume-optimize')?.addEventListener('click', () => {
            this.resumeOptimization();
        });

        // Stop buttons
        document.getElementById('btn-stop-optimize')?.addEventListener('click', () => {
            this.stopOptimization();
        });
        document.getElementById('btn-stop-optimize-2')?.addEventListener('click', () => {
            this.stopOptimization();
        });

        // Accept button
        document.getElementById('btn-accept-optimize')?.addEventListener('click', () => {
            this.acceptOptimization();
        });

        // Revert button
        document.getElementById('btn-revert-optimize')?.addEventListener('click', () => {
            this.revertOptimization();
        });

        // View Results button
        document.getElementById('btn-view-results')?.addEventListener('click', () => {
            this.openResultsView();
        });

        // Show optimizer button
        document.getElementById('btn-show-optimizer')?.addEventListener('click', () => {
            this.showOptimizerSection();
        });

        // Hide optimizer button
        document.getElementById('btn-hide-optimizer')?.addEventListener('click', () => {
            this.hideOptimizerSection();
        });

        // Set up results view controls
        this.setupResultsViewControls();

        // Set up optimizer callbacks
        this.optimizer.onProgress = (progress) => {
            this.updateOptimizerProgress(progress);
        };

        this.optimizer.onStep = (positions) => {
            // Live preview: apply positions and re-render (skip full recalculate for speed)
            positions.forEach((pos, id) => {
                const comp = this.store.getState().components.get(id);
                if (comp) {
                    comp.position = { ...pos };
                }
            });
            // Just render, don't recalculate - that happens at the end
            this.render();
        };

        this.optimizer.onComplete = (result) => {
            this.onOptimizationComplete(result);
        };
    }

    /**
     * Set up results view controls
     */
    setupResultsViewControls() {
        // Preview Selected button
        document.getElementById('btn-preview-selected')?.addEventListener('click', () => {
            this.previewSelectedSnapshot();
        });

        // Apply This Layout button
        document.getElementById('btn-apply-selected')?.addEventListener('click', () => {
            this.applySelectedSnapshot();
        });

        // Close Results View button
        document.getElementById('btn-close-results')?.addEventListener('click', () => {
            this.closeResultsView();
        });

        // Split-screen checkbox
        document.getElementById('results-split-screen')?.addEventListener('change', (e) => {
            this.isSplitScreenMode = e.target.checked;
            this.render();
        });
    }

    /**
     * Open the results view panel
     */
    openResultsView() {
        const snapshots = this.optimizer.getSnapshots();
        if (snapshots.length === 0) {
            alert('No optimization data available.');
            return;
        }

        // Show results section
        document.getElementById('results-section')?.classList.remove('hidden');
        this.isResultsViewOpen = true;

        // Initialize results graph if not already done
        const graphCanvas = document.getElementById('results-graph');
        if (graphCanvas && !this.resultsGraph) {
            this.resultsGraph = new ResultsGraph(graphCanvas);

            // Set up graph callbacks
            this.resultsGraph.onHover = (snapshot, index) => {
                this.updateResultsTooltip(snapshot);
            };

            this.resultsGraph.onClick = (snapshot, index) => {
                this.selectResultsSnapshot(snapshot, index);
            };

            this.resultsGraph.onDoubleClick = (snapshot, index) => {
                this.previewSnapshot = snapshot;
                this.render();
            };
        }

        // Load data into graph
        if (this.resultsGraph) {
            this.resultsGraph.setData(snapshots);
        }

        // Reset preview state
        this.previewSnapshot = null;
        this.isSplitScreenMode = false;
        document.getElementById('results-split-screen').checked = false;
    }

    /**
     * Close the results view panel
     */
    closeResultsView() {
        document.getElementById('results-section')?.classList.add('hidden');
        this.isResultsViewOpen = false;
        this.previewSnapshot = null;
        this.isSplitScreenMode = false;
        this.render();
    }

    /**
     * Update the tooltip when hovering over graph
     */
    updateResultsTooltip(snapshot) {
        const tooltipEl = document.getElementById('results-tooltip');
        if (!tooltipEl) return;

        if (snapshot) {
            tooltipEl.textContent = `Iteration ${snapshot.iteration}, Cost: ${snapshot.cost.toFixed(1)}`;
            tooltipEl.classList.add('active');
        } else {
            tooltipEl.textContent = 'Hover over graph to see iteration details';
            tooltipEl.classList.remove('active');
        }
    }

    /**
     * Select a snapshot from the results graph
     */
    selectResultsSnapshot(snapshot, index) {
        const selectedInfoEl = document.getElementById('selected-iteration-info');
        const previewBtn = document.getElementById('btn-preview-selected');
        const applyBtn = document.getElementById('btn-apply-selected');

        if (snapshot) {
            selectedInfoEl.textContent = `Iteration ${snapshot.iteration} (Cost: ${snapshot.cost.toFixed(1)})`;
            previewBtn.disabled = false;
            applyBtn.disabled = false;
        } else {
            selectedInfoEl.textContent = 'None';
            previewBtn.disabled = true;
            applyBtn.disabled = true;
        }
    }

    /**
     * Preview the selected snapshot
     */
    previewSelectedSnapshot() {
        if (!this.resultsGraph) return;

        const snapshot = this.resultsGraph.getSelectedSnapshot();
        if (snapshot) {
            this.previewSnapshot = snapshot;
            this.render();
        }
    }

    /**
     * Apply the selected snapshot to the actual state
     */
    applySelectedSnapshot() {
        if (!this.resultsGraph) return;

        const snapshot = this.resultsGraph.getSelectedSnapshot();
        if (!snapshot) return;

        // Apply the snapshot positions and angles
        this.optimizer.applySnapshot(snapshot, this.store.getState().components);

        // Recalculate and render
        this.store.dispatch(actions.markDirty());
        this.previewSnapshot = null;
        this.render();

        // Close results view
        this.closeResultsView();
    }

    /**
     * Get current optimization weights from sliders
     */
    getOptimizationWeights() {
        const comSlider = document.getElementById('weight-com');
        const footprintSlider = document.getElementById('weight-footprint');
        const pathSlider = document.getElementById('weight-path');

        const com = parseFloat(comSlider?.value || 50) / 100;
        const footprint = parseFloat(footprintSlider?.value || 25) / 100;
        const pathLength = parseFloat(pathSlider?.value || 25) / 100;

        // Normalize so they sum to 1
        const total = com + footprint + pathLength;
        return {
            com: com / total,
            footprint: footprint / total,
            pathLength: pathLength / total
        };
    }

    /**
     * Show optimizer section
     */
    showOptimizerSection() {
        const optimizerSection = document.getElementById('optimizer-section');
        const optimizerToggle = document.getElementById('optimizer-toggle-container');
        const selectionSection = document.getElementById('selection-info');

        optimizerSection.classList.remove('hidden');
        optimizerToggle.classList.add('hidden');

        // Also hide properties section when showing optimizer
        selectionSection.classList.add('hidden');
    }

    /**
     * Hide optimizer section
     */
    hideOptimizerSection() {
        const optimizerSection = document.getElementById('optimizer-section');
        const optimizerToggle = document.getElementById('optimizer-toggle-container');
        const state = this.store.getState();

        optimizerSection.classList.add('hidden');

        // Only show toggle button if nothing is selected
        const hasSelection = state.ui.selection.type === 'component' ||
                           state.ui.selection.type === 'zone' ||
                           state.ui.selection.type === 'segment';

        if (!hasSelection) {
            optimizerToggle.classList.remove('hidden');
        }

        // Re-render to update properties panel visibility
        this.render();
    }

    /**
     * Start optimization
     */
    startOptimization() {
        const state = this.store.getState();

        // Check if there are movable components
        const movableCount = Array.from(state.components.values())
            .filter(c => !c.isFixed).length;

        if (movableCount === 0) {
            alert('No movable components to optimize. Uncheck "Fixed Position" on components you want to move.');
            return;
        }

        // Store original positions and angles for revert
        this.originalPositionsBeforeOptimize = new Map();
        this.originalAnglesBeforeOptimize = new Map();
        state.components.forEach((comp, id) => {
            this.originalPositionsBeforeOptimize.set(id, { ...comp.position });
            this.originalAnglesBeforeOptimize.set(id, comp.angle);
        });

        // Get weights and start
        const weights = this.getOptimizationWeights();
        this.optimizer.start(state, weights);

        // Update UI
        this.showOptimizerButtons('running');
        document.getElementById('optimizer-progress').classList.remove('hidden');
    }

    /**
     * Pause optimization
     */
    pauseOptimization() {
        this.optimizer.pause();
        this.showOptimizerButtons('paused');
    }

    /**
     * Resume optimization
     */
    resumeOptimization() {
        this.optimizer.resume();
        this.showOptimizerButtons('running');
    }

    /**
     * Stop optimization
     */
    stopOptimization() {
        this.optimizer.stop();

        // Apply best positions found
        const bestPositions = this.optimizer.getBestPositions();
        bestPositions.forEach((pos, id) => {
            const comp = this.store.getState().components.get(id);
            if (comp) {
                comp.position = { ...pos };
            }
        });

        // Apply best angles found
        const bestAngles = this.optimizer.getBestAngles();
        bestAngles.forEach((angle, id) => {
            const comp = this.store.getState().components.get(id);
            if (comp) {
                comp.angle = angle;
            }
        });

        this.store.dispatch(actions.recalculate());
        this.render();

        // Show accept/revert buttons
        this.showOptimizerButtons('finished');
    }

    /**
     * Accept optimization results
     */
    acceptOptimization() {
        // Positions and angles are already applied, just reset UI
        this.originalPositionsBeforeOptimize = null;
        this.originalAnglesBeforeOptimize = null;
        this.showOptimizerButtons('start');
        document.getElementById('optimizer-progress').classList.add('hidden');
        this.store.dispatch(actions.markDirty());
    }

    /**
     * Revert optimization results
     */
    revertOptimization() {
        if (this.originalPositionsBeforeOptimize) {
            this.originalPositionsBeforeOptimize.forEach((pos, id) => {
                const comp = this.store.getState().components.get(id);
                if (comp) {
                    comp.position = { ...pos };
                }
            });
            this.originalPositionsBeforeOptimize = null;
        }

        // Revert angles
        if (this.originalAnglesBeforeOptimize) {
            this.originalAnglesBeforeOptimize.forEach((angle, id) => {
                const comp = this.store.getState().components.get(id);
                if (comp) {
                    comp.angle = angle;
                }
            });
            this.originalAnglesBeforeOptimize = null;
        }

        this.store.dispatch(actions.recalculate());
        this.render();

        this.showOptimizerButtons('start');
        document.getElementById('optimizer-progress').classList.add('hidden');
    }

    /**
     * Update optimizer progress UI
     */
    updateOptimizerProgress(progress) {
        // Update progress bar
        document.getElementById('opt-progress-bar').value = progress.progress * 100;

        // Update status text with meaningful information
        const statusText = document.getElementById('opt-status-text');
        if (progress.iterationsSinceImprovement > 100) {
            statusText.textContent = `Searching... (${progress.iterationsSinceImprovement} since improvement)`;
        } else if (progress.improvement > 0) {
            statusText.textContent = `Optimizing... found ${progress.improvement.toFixed(1)}% improvement`;
        } else {
            statusText.textContent = `Optimizing... (${Math.round(progress.progress * 100)}% complete)`;
        }

        // Update improvement percentage
        const improvementEl = document.getElementById('opt-improvement');
        improvementEl.textContent = `${progress.improvement.toFixed(1)}%`;
        improvementEl.className = 'opt-stat-value' + (progress.improvement > 5 ? ' good' : '');

        // Update iteration count
        document.getElementById('opt-iteration').textContent =
            `${progress.iteration}/${progress.maxIterations}`;

        // Update CoM distance from cost breakdown
        const comCostEl = document.getElementById('opt-com-cost');
        if (progress.costBreakdown && progress.costBreakdown.com !== undefined) {
            const comDist = Math.sqrt(progress.costBreakdown.com);
            comCostEl.textContent = comDist < 1 ? 'In zone' : `${comDist.toFixed(0)}mm`;
            comCostEl.className = 'opt-stat-value' + (comDist < 1 ? ' good' : '');
        }

        // Update violations count
        const penaltyEl = document.getElementById('opt-penalty');
        if (progress.costBreakdown && progress.costBreakdown.penalty !== undefined) {
            const violations = progress.costBreakdown.penalty > 0 ?
                Math.ceil(progress.costBreakdown.penalty / 1000) : 0;
            penaltyEl.textContent = violations.toString();
            penaltyEl.className = 'opt-stat-value' + (violations > 0 ? ' bad' : ' good');
        }
    }

    /**
     * Handle optimization complete
     */
    onOptimizationComplete(result) {
        console.log('Optimization complete:', result);

        // Do a full recalculate now that optimization is done
        this.store.dispatch(actions.recalculate());

        // Clear selection so optimizer buttons remain visible in the panel
        this.store.dispatch(actions.clearSelection());

        this.render();
        this.updateUI();

        // Update final status text
        const statusText = document.getElementById('opt-status-text');
        if (result.reason === 'earlyStop') {
            statusText.textContent = `Done! (converged after ${result.iteration} iterations)`;
        } else {
            statusText.textContent = `Done! (${result.improvement.toFixed(1)}% improvement)`;
        }

        this.showOptimizerButtons('finished');
    }

    /**
     * Show appropriate optimizer buttons for state
     */
    showOptimizerButtons(state) {
        const startBtns = document.getElementById('opt-buttons-start');
        const runningBtns = document.getElementById('opt-buttons-running');
        const pausedBtns = document.getElementById('opt-buttons-paused');
        const finishedBtns = document.getElementById('opt-buttons-finished');

        [startBtns, runningBtns, pausedBtns, finishedBtns].forEach(el => {
            if (el) el.classList.add('hidden');
        });

        switch (state) {
            case 'start':
                startBtns?.classList.remove('hidden');
                break;
            case 'running':
                runningBtns?.classList.remove('hidden');
                break;
            case 'paused':
                pausedBtns?.classList.remove('hidden');
                break;
            case 'finished':
                finishedBtns?.classList.remove('hidden');
                break;
        }
    }

    /**
     * Set the current tool
     */
    setTool(tool) {
        this.store.dispatch(actions.setTool(tool));

        // Update UI
        document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.tool === tool);
        });

        // Update cursor
        this.canvas.style.cursor = tool === 'pan' ? 'grab' :
                                   tool === 'select' ? 'default' : 'crosshair';
    }

    /**
     * Start placing a new component
     */
    startPlacingComponent(componentType) {
        const state = this.store.getState();
        this.store.dispatch(actions.setTool(componentType));
        this.canvas.style.cursor = 'crosshair';
    }

    /**
     * Handle mouse down on canvas
     */
    handleMouseDown(e) {
        const state = this.store.getState();
        const rect = this.canvas.getBoundingClientRect();
        const screenX = e.clientX - rect.left;
        const screenY = e.clientY - rect.top;
        const worldPos = this.renderer.screenToWorld(screenX, screenY, state.ui.viewport);

        const tool = state.ui.tool;

        // Check if clicking on a component
        const clickedComponent = this.getComponentAtPosition(worldPos.x, worldPos.y);
        // Check if clicking on a zone
        const clickedZone = this.getZoneAtPosition(worldPos.x, worldPos.y);

        if (tool === 'pan' || (e.button === 1) || (e.button === 0 && e.shiftKey && !e.ctrlKey)) {
            // Start panning
            this.isPanning = true;
            this.panStart = { x: screenX, y: screenY };
            this.canvas.style.cursor = 'grabbing';
        } else if (tool === 'select') {
            if (clickedComponent) {
                const wasAlreadySelected = state.ui.selection.selectedIds.includes(clickedComponent.id);

                // Ctrl+click for multi-select
                if (e.ctrlKey || e.metaKey) {
                    const currentSelected = [...state.ui.selection.selectedIds];
                    const idx = currentSelected.indexOf(clickedComponent.id);
                    if (idx > -1) {
                        // Deselect if already selected
                        currentSelected.splice(idx, 1);
                    } else {
                        // Add to selection
                        currentSelected.push(clickedComponent.id);
                    }
                    this.store.dispatch(actions.selectMultiple(currentSelected));
                } else if (!wasAlreadySelected) {
                    // Regular click on unselected component - select just this one
                    this.store.dispatch(actions.selectComponent(clickedComponent.id));
                }
                // If component was already selected (and no Ctrl), keep the current selection
                // This allows dragging multiple selected components together
                // Start dragging
                this.isDragging = true;
                this.dragStart = worldPos;
                this.dragComponent = clickedComponent;
                // Store original positions for beam constraint validation
                // IMPORTANT: We must determine which components will ACTUALLY be dragged,
                // not use stale state.ui.selection (which hasn't updated yet from the dispatch above)
                this.dragOriginalPositions = new Map();

                // Always include the clicked component
                this.dragOriginalPositions.set(clickedComponent.id, { ...clickedComponent.position });

                // For multi-select drag: if Ctrl was held OR if the clicked component was already selected,
                // include other previously selected components
                if ((e.ctrlKey || e.metaKey) || wasAlreadySelected) {
                    state.ui.selection.selectedIds.forEach(id => {
                        if (id !== clickedComponent.id) {
                            const comp = state.components.get(id);
                            if (comp) {
                                this.dragOriginalPositions.set(id, { ...comp.position });
                            }
                        }
                    });
                }

            } else if (clickedZone) {
                // Clicked on a zone
                this.store.dispatch(actions.selectZone(clickedZone.id));
                // Start dragging zone only if not fixed
                if (!clickedZone.zone.isFixed) {
                    this.isDragging = true;
                    this.dragStart = worldPos;
                    this.dragZone = clickedZone;
                    this.dragZoneOffset = {
                        x: worldPos.x - clickedZone.zone.bounds.x,
                        y: worldPos.y - clickedZone.zone.bounds.y
                    };
                }
            } else {
                // Clicked on empty area - start selection box
                this.store.dispatch(actions.clearSelection());
                this.isSelectionBoxDragging = true;
                this.selectionBoxStart = worldPos;
                // Update state with selection box (use fresh state after clearSelection)
                const freshState = this.store.getState();
                this.store.state = {
                    ...freshState,
                    ui: {
                        ...freshState.ui,
                        selectionBox: {
                            startX: worldPos.x,
                            startY: worldPos.y,
                            endX: worldPos.x,
                            endY: worldPos.y
                        }
                    }
                };
            }
        } else if (tool === 'connect') {
            // Beam connection mode - can select segments or create new connections
            // IMPORTANT: Prioritize component clicks over segment clicks
            // (segments end at components, so clicking a component would otherwise select the segment)

            if (clickedComponent && clickedComponent.canOutputBeam()) {
                // Start creating new connection from this component
                this.connectingFrom = clickedComponent;
                console.log('Connecting from:', clickedComponent.name);
            } else if (clickedComponent && clickedComponent.canReceiveBeam()) {
                // Clicked on a component that can only receive (like detector with no outgoing)
                // Check for segment selection instead
                const clickedSegment = this.getSegmentAtPosition(worldPos.x, worldPos.y);
                if (clickedSegment) {
                    if (e.ctrlKey || e.metaKey) {
                        const currentSelected = [...(state.ui.selection.selectedSegmentIds || [])];
                        const idx = currentSelected.indexOf(clickedSegment.id);
                        if (idx > -1) {
                            currentSelected.splice(idx, 1);
                        } else {
                            currentSelected.push(clickedSegment.id);
                        }
                        this.store.dispatch(actions.selectMultipleSegments(currentSelected));
                    } else {
                        this.store.dispatch(actions.selectSegment(clickedSegment.id));
                    }
                }
            } else {
                // No component clicked - check for segment selection
                const clickedSegment = this.getSegmentAtPosition(worldPos.x, worldPos.y);
                if (clickedSegment) {
                    // Ctrl+click for multi-select segments
                    if (e.ctrlKey || e.metaKey) {
                        const currentSelected = [...(state.ui.selection.selectedSegmentIds || [])];
                        const idx = currentSelected.indexOf(clickedSegment.id);
                        if (idx > -1) {
                            currentSelected.splice(idx, 1);
                        } else {
                            currentSelected.push(clickedSegment.id);
                        }
                        this.store.dispatch(actions.selectMultipleSegments(currentSelected));
                    } else {
                        // Regular click - select single segment
                        this.store.dispatch(actions.selectSegment(clickedSegment.id));
                    }
                } else {
                    // Clicked on empty area in connect mode - start selection box for segments
                    this.store.dispatch(actions.clearSelection());
                    this.isSelectionBoxDragging = true;
                    this.selectionBoxStart = worldPos;
                    const freshState = this.store.getState();
                    this.store.state = {
                        ...freshState,
                        ui: {
                            ...freshState.ui,
                            selectionBox: {
                                startX: worldPos.x,
                                startY: worldPos.y,
                                endX: worldPos.x,
                                endY: worldPos.y
                            }
                        }
                    };
                }
            }
        } else if (tool === 'keepout') {
            // Start drawing keep-out zone
            this.zoneStart = worldPos;
        } else if (tool === 'mounting') {
            // Start drawing mounting zone
            this.zoneStart = worldPos;
        } else if (Object.values(ComponentType).includes(tool)) {
            // Placing a new component
            this.placeComponent(tool, worldPos);
        }
    }

    /**
     * Handle mouse move on canvas
     */
    handleMouseMove(e) {
        const state = this.store.getState();
        const rect = this.canvas.getBoundingClientRect();
        const screenX = e.clientX - rect.left;
        const screenY = e.clientY - rect.top;
        const worldPos = this.renderer.screenToWorld(screenX, screenY, state.ui.viewport);

        // Update cursor position in status bar
        document.getElementById('cursor-position').textContent =
            `(${worldPos.x.toFixed(1)}, ${worldPos.y.toFixed(1)})`;

        if (this.isPanning) {
            // Pan the viewport
            const dx = screenX - this.panStart.x;
            const dy = screenY - this.panStart.y;
            this.store.dispatch(actions.setViewport({
                panX: state.ui.viewport.panX + dx,
                panY: state.ui.viewport.panY + dy
            }));
            this.panStart = { x: screenX, y: screenY };
        } else if (this.isSelectionBoxDragging) {
            // Update selection box
            const newState = {
                ...state,
                ui: {
                    ...state.ui,
                    selectionBox: {
                        startX: this.selectionBoxStart.x,
                        startY: this.selectionBoxStart.y,
                        endX: worldPos.x,
                        endY: worldPos.y
                    }
                }
            };
            this.store.state = newState;
            this.render();
        } else if (this.isDragging && this.dragComponent) {
            // Move component(s)
            if (!this.dragComponent.isFixed) {
                // If multiple components selected, move all of them
                const selectedIds = state.ui.selection.selectedIds;
                if (selectedIds.length > 1 && selectedIds.includes(this.dragComponent.id) && this.dragOriginalPositions) {
                    // Calculate total delta from ORIGINAL drag start position
                    const dx = worldPos.x - this.dragStart.x;
                    const dy = worldPos.y - this.dragStart.y;

                    // Use original positions to calculate new positions
                    // This avoids issues with stale state during multiple dispatches
                    this.dragOriginalPositions.forEach((origPos, id) => {
                        const comp = state.components.get(id);
                        if (comp && !comp.isFixed) {
                            let newPos = {
                                x: origPos.x + dx,
                                y: origPos.y + dy
                            };
                            // Apply grid snapping if enabled globally and for this component
                            const gridEnabled = state.grid?.enabled !== false;
                            if (gridEnabled && comp.snapToGrid !== false) {
                                newPos = BeamPhysics.snapToGrid(newPos, state.grid?.size || 25);
                            }
                            this.store.dispatch(actions.moveComponent(id, newPos));
                        }
                    });
                    // NOTE: Don't update dragStart - we use original positions and total delta
                } else {
                    // Single component drag - position follows mouse directly
                    let newPos = { x: worldPos.x, y: worldPos.y };
                    const gridEnabled = state.grid?.enabled !== false;
                    if (gridEnabled && this.dragComponent.snapToGrid !== false) {
                        newPos = BeamPhysics.snapToGrid(newPos, state.grid?.size || 25);
                    }
                    this.store.dispatch(actions.moveComponent(this.dragComponent.id, newPos));
                }
            }
        } else if (this.isDragging && this.dragZone) {
            // Move zone
            const newX = worldPos.x - this.dragZoneOffset.x;
            const newY = worldPos.y - this.dragZoneOffset.y;
            this.store.dispatch(actions.moveZone(this.dragZone.id, { x: newX, y: newY }));
        } else {
            // Hover detection for components, zones, and segments
            const hovered = this.getComponentAtPosition(worldPos.x, worldPos.y);
            const hoveredZone = !hovered ? this.getZoneAtPosition(worldPos.x, worldPos.y) : null;
            // Only check for segment hover in connect mode
            const hoveredSegment = (state.ui.tool === 'connect' && !hovered && !hoveredZone)
                ? this.getSegmentAtPosition(worldPos.x, worldPos.y)
                : null;

            const currentHovered = state.ui.selection.hoveredId;
            const currentHoveredZone = state.ui.selection.hoveredZoneId;
            const currentHoveredSegment = state.ui.selection.hoveredSegmentId;

            if (hovered?.id !== currentHovered ||
                hoveredZone?.id !== currentHoveredZone ||
                hoveredSegment?.id !== currentHoveredSegment) {
                // Update hover state (without adding to history)
                const newState = {
                    ...state,
                    ui: {
                        ...state.ui,
                        selection: {
                            ...state.ui.selection,
                            hoveredId: hovered?.id || null,
                            hoveredZoneId: hoveredZone?.id || null,
                            hoveredSegmentId: hoveredSegment?.id || null
                        }
                    }
                };
                // Direct state update for hover (not through dispatch to avoid history)
                this.store.state = newState;
                this.render();
            }
        }
    }

    /**
     * Handle mouse up on canvas
     */
    handleMouseUp(e) {
        const state = this.store.getState();
        const rect = this.canvas.getBoundingClientRect();
        const screenX = e.clientX - rect.left;
        const screenY = e.clientY - rect.top;
        const worldPos = this.renderer.screenToWorld(screenX, screenY, state.ui.viewport);

        if (this.isPanning) {
            this.isPanning = false;
            this.canvas.style.cursor = state.ui.tool === 'pan' ? 'grab' : 'default';
        }

        if (this.isDragging) {
            // Validate beam constraints before finalizing drag
            if (this.dragOriginalPositions && this.dragOriginalPositions.size > 0) {
                const validation = this.validateMovementForBeamConstraints(this.dragOriginalPositions);
                if (!validation.valid) {
                    // Snap back to original positions
                    this.dragOriginalPositions.forEach((origPos, id) => {
                        const comp = state.components.get(id);
                        if (comp) {
                            comp.position = { ...origPos };
                        }
                    });
                    this.store.dispatch(actions.recalculate());
                    this.render();
                    // Show warning
                    this.showMovementWarning(validation.error);
                } else if (state.ui.autoPropagate) {
                    // Valid movement and auto-propagate is on - update beam connections
                    this.propagateAllBeams();
                }
            }
            this.isDragging = false;
            this.dragComponent = null;
            this.dragZone = null;
            this.dragZoneOffset = null;
            this.dragOriginalPositions = null;
        }

        // Handle selection box completion
        if (this.isSelectionBoxDragging) {
            const box = state.ui.selectionBox;
            if (box) {
                // Calculate box size to distinguish between click and drag
                const boxWidth = Math.abs(box.endX - box.startX);
                const boxHeight = Math.abs(box.endY - box.startY);
                const isClick = boxWidth < 5 && boxHeight < 5; // Less than 5mm = click, not drag

                // Only select components if user actually dragged (not just clicked)
                if (!isClick) {
                    // In connect mode, select segments; otherwise select components
                    if (state.ui.tool === 'connect') {
                        const selectedSegmentIds = this.getSegmentsInBox(box);
                        if (selectedSegmentIds.length > 0) {
                            this.store.dispatch(actions.selectMultipleSegments(selectedSegmentIds));
                        }
                    } else {
                        const selectedIds = this.getComponentsInBox(box);
                        if (selectedIds.length > 0) {
                            this.store.dispatch(actions.selectMultiple(selectedIds));
                        }
                    }
                }
                // If it was just a click (isClick = true), selection was already cleared in mouseDown
            }
            // Clear selection box
            this.isSelectionBoxDragging = false;
            this.selectionBoxStart = null;
            this.store.state = {
                ...this.store.state,
                ui: {
                    ...this.store.state.ui,
                    selectionBox: null
                }
            };
            this.render();
        }

        // Handle beam connection completion
        if (this.connectingFrom) {
            const clickedComponent = this.getComponentAtPosition(worldPos.x, worldPos.y);
            if (clickedComponent && clickedComponent.id !== this.connectingFrom.id &&
                clickedComponent.canReceiveBeam()) {
                this.createBeamConnection(this.connectingFrom, clickedComponent);
            }
            this.connectingFrom = null;
        }

        // Handle zone drawing completion
        if (this.zoneStart) {
            const zone = {
                id: `zone_${Date.now()}`,
                name: state.ui.tool === 'keepout' ? 'Keep-Out Zone' : 'Mounting Zone',
                bounds: {
                    x: Math.min(this.zoneStart.x, worldPos.x),
                    y: Math.min(this.zoneStart.y, worldPos.y),
                    width: Math.abs(worldPos.x - this.zoneStart.x),
                    height: Math.abs(worldPos.y - this.zoneStart.y)
                },
                rotation: 0,  // Rotation angle in degrees (45Â° increments)
                isFixed: false,  // Whether zone location is fixed
                isActive: true
            };

            if (zone.bounds.width > 10 && zone.bounds.height > 10) {
                if (state.ui.tool === 'keepout') {
                    this.store.dispatch(actions.addKeepOutZone(zone));
                    // Auto-select the new keepout zone
                    this.store.dispatch(actions.selectZone(`keepout:${zone.id}`));
                } else if (state.ui.tool === 'mounting') {
                    this.store.dispatch(actions.setMountingZone(zone));
                    // Mounting zone auto-selects in state reducer
                }
            }

            this.zoneStart = null;
            this.setTool('select');
        }
    }

    /**
     * Handle mouse wheel for zooming
     */
    handleWheel(e) {
        e.preventDefault();
        const factor = e.deltaY > 0 ? 0.9 : 1.1;
        this.zoom(factor);
    }

    /**
     * Handle keyboard shortcuts
     */
    handleKeyDown(e) {
        // Don't handle if typing in input
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

        const state = this.store.getState();

        switch (e.key) {
            case 'Delete':
            case 'Backspace':
                this.deleteSelected();
                break;
            case 'Escape':
                // Exit preview mode if active
                if (this.previewSnapshot) {
                    this.previewSnapshot = null;
                    this.render();
                    break;
                }
                // Close results view if open
                if (this.isResultsViewOpen) {
                    this.closeResultsView();
                    break;
                }
                this.store.dispatch(actions.clearSelection());
                this.setTool('select');
                break;
            case 'v':
            case 'V':
                // If 2+ components selected, align vertically; otherwise switch to select tool
                if (state.ui.selection.selectedIds.length >= 2) {
                    this.alignComponentsVertically();
                } else {
                    this.setTool('select');
                }
                break;
            case 'h':
            case 'H':
                // If 2+ components selected, align horizontally; otherwise switch to pan tool
                if (state.ui.selection.selectedIds.length >= 2) {
                    this.alignComponentsHorizontally();
                } else {
                    this.setTool('pan');
                }
                break;
            case 'c':
            case 'C':
                this.setTool('connect');
                break;
            case 'o':
            case 'O':
                this.toggleLaser();
                break;
            case 'l':
            case 'L':
                this.startPlacingComponent(ComponentType.LENS);
                break;
            case 'r':
            case 'R':
                this.rotateSelectedComponents(e);
                break;
            case 'u':
            case 'U':
                this.unconstrainSelectedComponents();
                break;
            case 'f':
            case 'F':
                this.toggleFixSelected();
                break;
            case 'm':
            case 'M':
                this.startPlacingComponent(ComponentType.MIRROR);
                break;
            case 's':
            case 'S':
                if (e.ctrlKey || e.metaKey) {
                    e.preventDefault();
                    this.saveDocument();
                } else {
                    this.startPlacingComponent(ComponentType.SOURCE);
                }
                break;
            case 'b':
            case 'B':
                this.startPlacingComponent(ComponentType.BEAM_SPLITTER);
                break;
            case 'w':
            case 'W':
                this.startPlacingComponent(ComponentType.WAVEPLATE);
                break;
            case 'i':
            case 'I':
                this.startPlacingComponent(ComponentType.FILTER);
                break;
            case 'd':
            case 'D':
                this.startPlacingComponent(ComponentType.DETECTOR);
                break;
            case 'a':
            case 'A':
                if (e.ctrlKey || e.metaKey) {
                    e.preventDefault();
                    this.selectAllComponents();
                }
                break;
            case 'z':
            case 'Z':
                if (e.ctrlKey || e.metaKey) {
                    e.preventDefault();
                    if (e.shiftKey) {
                        this.redo();
                    } else {
                        this.undo();
                    }
                } else {
                    // Toggle mount zone for selected components
                    this.toggleMountZoneSelected();
                }
                break;
            case 'y':
            case 'Y':
                if (e.ctrlKey || e.metaKey) {
                    e.preventDefault();
                    this.redo();
                }
                break;
            case '+':
            case '=':
                this.zoom(1.2);
                break;
            case '-':
                this.zoom(0.8);
                break;
        }
    }

    /**
     * Get component at world position
     */
    getComponentAtPosition(x, y) {
        const state = this.store.getState();
        const components = Array.from(state.components.values());

        // Check in reverse order (top-most first)
        for (let i = components.length - 1; i >= 0; i--) {
            if (components[i].containsPoint(x, y)) {
                return components[i];
            }
        }
        return null;
    }

    /**
     * Get zone at world position
     * Returns { type: 'keepout' | 'mounting', id: string, zone: object } or null
     */
    getZoneAtPosition(x, y) {
        const state = this.store.getState();

        // Check mounting zone first (higher priority)
        const mountingZone = state.constraints.mountingZone;
        if (mountingZone) {
            const b = mountingZone.bounds;
            if (x >= b.x && x <= b.x + b.width && y >= b.y && y <= b.y + b.height) {
                return { type: 'mounting', id: 'mounting', zone: mountingZone };
            }
        }

        // Check keep-out zones
        for (const zone of state.constraints.keepOutZones) {
            if (!zone.isActive) continue;
            const b = zone.bounds;
            if (x >= b.x && x <= b.x + b.width && y >= b.y && y <= b.y + b.height) {
                return { type: 'keepout', id: `keepout:${zone.id}`, zone };
            }
        }

        return null;
    }

    /**
     * Calculate distance from a point to a line segment
     * @returns {number} Distance in world units
     */
    pointToSegmentDistance(px, py, x1, y1, x2, y2) {
        const A = px - x1;
        const B = py - y1;
        const C = x2 - x1;
        const D = y2 - y1;

        const dot = A * C + B * D;
        const lenSq = C * C + D * D;
        let param = -1;

        if (lenSq !== 0) {
            param = dot / lenSq;
        }

        let xx, yy;

        if (param < 0) {
            xx = x1;
            yy = y1;
        } else if (param > 1) {
            xx = x2;
            yy = y2;
        } else {
            xx = x1 + param * C;
            yy = y1 + param * D;
        }

        const dx = px - xx;
        const dy = py - yy;
        return Math.sqrt(dx * dx + dy * dy);
    }

    /**
     * Get beam segment at world position (within threshold)
     * @returns {BeamSegment | null}
     */
    getSegmentAtPosition(x, y, threshold = 8) {
        const state = this.store.getState();
        const segments = state.beamPath.getAllSegments();
        const components = state.components;
        const zoom = state.ui.viewport.zoom;

        // Adjust threshold based on zoom
        const adjustedThreshold = threshold / zoom;

        let closestSegment = null;
        let closestDistance = Infinity;

        for (const segment of segments) {
            const source = components.get(segment.sourceId);
            const target = components.get(segment.targetId);
            if (!source || !target) continue;

            const dist = this.pointToSegmentDistance(
                x, y,
                source.position.x, source.position.y,
                target.position.x, target.position.y
            );

            if (dist < adjustedThreshold && dist < closestDistance) {
                closestDistance = dist;
                closestSegment = segment;
            }
        }

        return closestSegment;
    }

    /**
     * Get all beam segments within a bounding box
     * @returns {string[]} Array of segment IDs
     */
    getSegmentsInBox(box) {
        const state = this.store.getState();
        const segments = state.beamPath.getAllSegments();
        const components = state.components;
        const selected = [];

        const minX = Math.min(box.startX, box.endX);
        const maxX = Math.max(box.startX, box.endX);
        const minY = Math.min(box.startY, box.endY);
        const maxY = Math.max(box.startY, box.endY);

        for (const segment of segments) {
            const source = components.get(segment.sourceId);
            const target = components.get(segment.targetId);
            if (!source || !target) continue;

            // Check if segment midpoint is in box (simple check)
            const midX = (source.position.x + target.position.x) / 2;
            const midY = (source.position.y + target.position.y) / 2;

            if (midX >= minX && midX <= maxX && midY >= minY && midY <= maxY) {
                selected.push(segment.id);
            }
        }

        return selected;
    }

    /**
     * Get all components within a bounding box
     */
    getComponentsInBox(box) {
        const state = this.store.getState();
        const components = Array.from(state.components.values());
        const selected = [];

        const minX = Math.min(box.startX, box.endX);
        const maxX = Math.max(box.startX, box.endX);
        const minY = Math.min(box.startY, box.endY);
        const maxY = Math.max(box.startY, box.endY);

        for (const comp of components) {
            const pos = comp.position;
            if (pos.x >= minX && pos.x <= maxX && pos.y >= minY && pos.y <= maxY) {
                selected.push(comp.id);
            }
        }

        return selected;
    }

    /**
     * Validate if component movement maintains valid beam constraints
     * @param {Map} originalPositions - Map of component IDs to their original positions
     * @returns {{ valid: boolean, error: string | null }}
     */
    validateMovementForBeamConstraints(originalPositions) {
        const state = this.store.getState();
        const beamPath = state.beamPath;
        const components = state.components;

        // For each moved component, check if any connected beams are now invalid
        for (const [compId, origPos] of originalPositions) {
            const comp = components.get(compId);
            if (!comp) continue;

            // Check incoming beam segments
            const incomingSegments = beamPath.getIncomingSegments(compId);
            for (const segment of incomingSegments) {
                const sourceComp = components.get(segment.sourceId);
                if (!sourceComp) continue;

                // Skip if source was also moved (relative position maintained)
                if (originalPositions.has(segment.sourceId)) continue;

                // Calculate new beam angle from source to target
                const newAngle = BeamPhysics.calculateBeamAngle(sourceComp.position, comp.position);
                if (newAngle === null) continue;

                // Get expected output angle from source
                let incomingAngleToSource = null;
                if (sourceComp.type === 'source') {
                    incomingAngleToSource = sourceComp.emissionAngle || 0;
                } else {
                    // Get from upstream segment
                    const sourceIncoming = beamPath.getIncomingSegments(sourceComp.id);
                    if (sourceIncoming.length > 0) {
                        const upstreamSource = components.get(sourceIncoming[0].sourceId);
                        if (upstreamSource) {
                            incomingAngleToSource = BeamPhysics.calculateBeamAngle(upstreamSource.position, sourceComp.position);
                        }
                    }
                }

                if (incomingAngleToSource !== null) {
                    const expectedAngle = BeamPhysics.getOutputDirection(sourceComp, incomingAngleToSource, segment.sourcePort);
                    if (expectedAngle !== null) {
                        // Calculate deviation
                        const deviation = Math.abs(BeamPhysics.normalizeAngle(newAngle - expectedAngle));
                        const normalizedDev = Math.min(deviation, 360 - deviation);

                        // If deviation is too large, reject the move
                        if (normalizedDev > BeamPhysics.ANGLE_TOLERANCE) {
                            return {
                                valid: false,
                                error: `Movement would break beam connection from ${sourceComp.name} to ${comp.name}. Beam angle deviation: ${normalizedDev.toFixed(1)}Â°`
                            };
                        }
                    }
                }
            }

            // Check outgoing beam segments
            const outgoingSegments = beamPath.getOutgoingSegments(compId);
            for (const segment of outgoingSegments) {
                const targetComp = components.get(segment.targetId);
                if (!targetComp) continue;

                // Skip if target was also moved (relative position maintained)
                if (originalPositions.has(segment.targetId)) continue;

                // Calculate new beam angle from source to target
                const newAngle = BeamPhysics.calculateBeamAngle(comp.position, targetComp.position);
                if (newAngle === null) continue;

                // Get expected output angle from this component
                let incomingAngle = null;
                if (comp.type === 'source') {
                    incomingAngle = comp.emissionAngle || 0;
                } else {
                    const compIncoming = beamPath.getIncomingSegments(comp.id);
                    if (compIncoming.length > 0) {
                        const upstreamSource = components.get(compIncoming[0].sourceId);
                        if (upstreamSource) {
                            incomingAngle = BeamPhysics.calculateBeamAngle(upstreamSource.position, comp.position);
                        }
                    }
                }

                if (incomingAngle !== null) {
                    const expectedAngle = BeamPhysics.getOutputDirection(comp, incomingAngle, segment.sourcePort);
                    if (expectedAngle !== null) {
                        const deviation = Math.abs(BeamPhysics.normalizeAngle(newAngle - expectedAngle));
                        const normalizedDev = Math.min(deviation, 360 - deviation);

                        if (normalizedDev > BeamPhysics.ANGLE_TOLERANCE) {
                            return {
                                valid: false,
                                error: `Movement would break beam connection from ${comp.name} to ${targetComp.name}. Beam angle deviation: ${normalizedDev.toFixed(1)}Â°`
                            };
                        }
                    }
                }
            }
        }

        return { valid: true, error: null };
    }

    /**
     * Show a warning toast for movement constraint violation
     */
    showMovementWarning(message) {
        this.showToast(message, 'danger');
    }

    /**
     * Show a toast notification
     * @param {string} message - The message to display
     * @param {string} type - The type: 'success', 'warning', 'danger', 'info'
     */
    showToast(message, type = 'info') {
        // Create toast element if it doesn't exist
        let toast = document.getElementById('app-toast');
        if (!toast) {
            toast = document.createElement('div');
            toast.id = 'app-toast';
            toast.style.cssText = `
                position: fixed;
                bottom: 80px;
                left: 50%;
                transform: translateX(-50%);
                color: white;
                padding: 12px 24px;
                border-radius: 8px;
                font-size: 14px;
                z-index: 10000;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                opacity: 0;
                transition: opacity 0.3s ease;
            `;
            document.body.appendChild(toast);
        }

        // Set background color based on type
        const colors = {
            success: '#22c55e',
            warning: '#f59e0b',
            danger: '#ef4444',
            info: '#3b82f6'
        };
        toast.style.background = colors[type] || colors.info;

        // Show the toast
        toast.textContent = message;
        toast.style.opacity = '1';

        // Hide after 3 seconds
        setTimeout(() => {
            toast.style.opacity = '0';
        }, 3000);
    }

    /**
     * Handle dragging a component from the palette
     */
    handlePaletteDrag(e) {
        if (!this.dragComponentType || !this.paletteMouseStart) return;

        // Check if we've moved enough to start dragging (5px threshold)
        const dx = e.clientX - this.paletteMouseStart.x;
        const dy = e.clientY - this.paletteMouseStart.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (!this.isDraggingFromPalette && distance > 5) {
            // Start dragging - create preview element
            this.isDraggingFromPalette = true;
            this.createDragPreview(this.dragComponentType);
        }

        if (this.isDraggingFromPalette && this.dragPreviewElement) {
            // Update preview position
            this.dragPreviewElement.style.left = `${e.clientX}px`;
            this.dragPreviewElement.style.top = `${e.clientY}px`;

            // Check if over canvas and show snapped position
            const rect = this.canvas.getBoundingClientRect();
            if (e.clientX >= rect.left && e.clientX <= rect.right &&
                e.clientY >= rect.top && e.clientY <= rect.bottom) {
                const state = this.store.getState();
                const screenX = e.clientX - rect.left;
                const screenY = e.clientY - rect.top;
                const worldPos = this.renderer.screenToWorld(screenX, screenY, state.ui.viewport);
                const gridSize = state.grid?.size || 25;
                const gridEnabled = state.grid?.enabled !== false;
                const snappedPos = gridEnabled ? BeamPhysics.snapToGrid(worldPos, gridSize) : worldPos;

                // Update preview to show snapped position hint
                this.dragPreviewElement.classList.add('over-canvas');
                this.dragPreviewElement.dataset.snapped = `(${Math.round(snappedPos.x)}, ${Math.round(snappedPos.y)})`;
            } else {
                this.dragPreviewElement.classList.remove('over-canvas');
            }
        }
    }

    /**
     * Handle dropping a component from the palette
     */
    handlePaletteDrop(e) {
        if (this.isDraggingFromPalette && this.dragComponentType) {
            // Check if dropped on canvas
            const rect = this.canvas.getBoundingClientRect();
            if (e.clientX >= rect.left && e.clientX <= rect.right &&
                e.clientY >= rect.top && e.clientY <= rect.bottom) {
                const state = this.store.getState();
                const screenX = e.clientX - rect.left;
                const screenY = e.clientY - rect.top;
                const worldPos = this.renderer.screenToWorld(screenX, screenY, state.ui.viewport);
                const gridSize = state.grid?.size || 25;
                const gridEnabled = state.grid?.enabled !== false;
                const snappedPos = gridEnabled ? BeamPhysics.snapToGrid(worldPos, gridSize) : worldPos;

                this.placeComponent(this.dragComponentType, snappedPos);
            }
        }

        // Clean up
        this.removeDragPreview();
        this.isDraggingFromPalette = false;
        this.dragComponentType = null;
        this.paletteMouseStart = null;
    }

    /**
     * Create a visual preview element for dragging
     */
    createDragPreview(componentType) {
        this.removeDragPreview(); // Clean up any existing preview

        const preview = document.createElement('div');
        preview.className = 'component-drag-preview';
        preview.innerHTML = `
            <span class="comp-icon ${componentType}"></span>
            <span class="comp-name">${ComponentNames[componentType] || componentType}</span>
        `;
        document.body.appendChild(preview);
        this.dragPreviewElement = preview;
    }

    /**
     * Remove the drag preview element
     */
    removeDragPreview() {
        if (this.dragPreviewElement) {
            this.dragPreviewElement.remove();
            this.dragPreviewElement = null;
        }
    }

    /**
     * Place a new component
     */
    placeComponent(type, position) {
        const component = Component.create(type, position);
        this.store.dispatch(actions.addComponent(component));
        this.setTool('select');

        // Trigger beam propagation if enabled
        const state = this.store.getState();
        if (state.ui.autoPropagate) {
            this.propagateAllBeams();
        }
    }

    /**
     * Create beam connection between components
     * Validates physics constraints before creating the connection
     */
    createBeamConnection(source, target) {
        const state = this.store.getState();

        // Determine output port
        let sourcePort = 'output';
        if (source.type === ComponentType.MIRROR) {
            sourcePort = 'reflected';
        } else if (source.type === ComponentType.BEAM_SPLITTER) {
            // Determine available ports based on reflectance/transmittance
            const reflectance = source.reflectance ?? 0.5;
            const transmittance = source.transmittance ?? (1 - reflectance);

            const existingSegments = state.beamPath.getOutgoingSegments(source.id);
            const usedPorts = existingSegments.map(s => s.sourcePort);

            // Prefer reflected port if available and reflectance > 0
            if (!usedPorts.includes('reflected') && reflectance > 0) {
                sourcePort = 'reflected';
            } else if (!usedPorts.includes('transmitted') && transmittance > 0) {
                sourcePort = 'transmitted';
            } else if (reflectance > 0) {
                sourcePort = 'reflected';
            } else if (transmittance > 0) {
                sourcePort = 'transmitted';
            } else {
                // Both are zero - shouldn't happen but default to reflected
                sourcePort = 'reflected';
            }
        } else if (source.splitsBeam && source.splitsBeam()) {
            sourcePort = 'transmitted';
        }

        // === Physics Validation ===

        // Determine incoming beam angle for non-source components
        let incomingBeamAngle = null;
        if (source.type !== ComponentType.SOURCE) {
            const incomingSegments = state.beamPath.getIncomingSegments(source.id);
            if (incomingSegments.length > 0) {
                // Get the incoming beam direction
                const incomingSegment = incomingSegments[0];
                const prevComponent = state.components.get(incomingSegment.sourceId);
                if (prevComponent) {
                    incomingBeamAngle = BeamPhysics.calculateBeamAngle(
                        prevComponent.position,
                        source.position
                    );
                }
            }
        }

        // Build component map for validation
        const componentMap = state.components;

        // Validate the connection using physics
        const validation = BeamPhysics.validateConnection(
            source,
            target,
            sourcePort,
            incomingBeamAngle,
            componentMap
        );

        if (!validation.valid) {
            // Show error message to user
            this.showConnectionError(validation.error);
            console.warn(`Connection blocked: ${validation.error}`);
            return;
        }

        // Get active wavelength for new beam
        const activeWavelengthId = state.activeWavelengthId;

        // Create the segment with physics data
        const segment = new BeamSegment({
            sourceId: source.id,
            targetId: target.id,
            sourcePort,
            targetPort: 'input',
            direction: validation.beamDirection,
            directionAngle: validation.beamAngle,
            isValid: true,
            wavelengthIds: activeWavelengthId ? [activeWavelengthId] : []
        });


        this.store.dispatch(actions.addBeamSegment(segment));
        console.log(`Connected ${source.name} -> ${target.name} (angle: ${validation.beamAngle?.toFixed(1)}Â°)`);

        // Trigger beam propagation from target if enabled
        if (state.ui.autoPropagate) {
            this.propagateAllBeams();
        }
    }

    /**
     * Show connection error message to user
     */
    showConnectionError(message) {
        // Create toast notification
        const toast = document.createElement('div');
        toast.className = 'connection-error-toast';
        toast.innerHTML = `
            <span class="error-icon">â ï¸</span>
            <span class="error-message">Invalid connection: ${message}</span>
        `;
        toast.style.cssText = `
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #dc2626;
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            z-index: 10000;
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 500;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            animation: slideDown 0.3s ease-out;
        `;

        document.body.appendChild(toast);

        // Remove after 4 seconds
        setTimeout(() => {
            toast.style.animation = 'fadeOut 0.3s ease-out forwards';
            setTimeout(() => toast.remove(), 300);
        }, 4000);
    }

    /**
     * Delete selected components, zones, or beam segments
     */
    deleteSelected() {
        const state = this.store.getState();

        // Delete selected components
        if (state.ui.selection.type === 'component') {
            state.ui.selection.selectedIds.forEach(id => {
                this.store.dispatch(actions.deleteComponent(id));
            });
        }

        // Delete selected zone
        if (state.ui.selection.type === 'zone') {
            const zoneId = state.ui.selection.selectedZoneId;
            if (zoneId === 'mounting') {
                this.store.dispatch(actions.deleteMountingZone());
            } else if (zoneId && zoneId.startsWith('keepout:')) {
                const id = zoneId.replace('keepout:', '');
                this.store.dispatch(actions.deleteKeepOutZone(id));
            }
        }

        // Delete selected beam segments
        if (state.ui.selection.type === 'segment') {
            const segmentIds = state.ui.selection.selectedSegmentIds || [];
            segmentIds.forEach(id => {
                this.store.dispatch(actions.deleteBeamSegment(id));
            });
            // Clear selection after deletion
            this.store.dispatch(actions.clearSelection());
        }
    }

    /**
     * Duplicate selected components
     */
    duplicateSelected() {
        const state = this.store.getState();
        state.ui.selection.selectedIds.forEach(id => {
            const component = state.components.get(id);
            if (component) {
                const clone = component.clone();
                clone.position = {
                    x: component.position.x + 30,
                    y: component.position.y + 30
                };

                // Generate smart incremented name instead of adding "(copy)"
                clone.name = this.generateIncrementedName(component.name, state.components);

                this.store.dispatch(actions.addComponent(clone));
            }
        });
    }

    /**
     * Generate an incremented name for a duplicated component
     * E.g., M2 -> M3, or M3 -> M4 (if M3 exists, try M4, M5, etc.)
     */
    generateIncrementedName(baseName, components) {
        // Remove ' (copy)' suffix if it exists (from old clones)
        baseName = baseName.replace(/\s*\(copy\)$/i, '');

        // Extract base name and number
        // Match patterns like "M2", "Mirror 3", "L1", "Lens1", etc.
        const match = baseName.match(/^(.*?)(\d+)$/);

        let namePrefix, currentNumber;
        if (match) {
            namePrefix = match[1];  // "M", "Mirror ", "L", etc.
            currentNumber = parseInt(match[2], 10);  // 2, 3, 1, etc.
        } else {
            // No number in name, treat whole thing as prefix and start at 1
            namePrefix = baseName;
            currentNumber = 0;
        }

        // Find the next available number
        let nextNumber = currentNumber + 1;
        let candidateName = namePrefix + nextNumber;

        // Keep incrementing until we find an unused name
        while (Array.from(components.values()).some(comp => comp.name === candidateName)) {
            nextNumber++;
            candidateName = namePrefix + nextNumber;
        }

        return candidateName;
    }

    /**
     * Select all components
     */
    selectAllComponents() {
        const state = this.store.getState();
        const allComponentIds = Array.from(state.components.keys());

        if (allComponentIds.length > 0) {
            this.store.dispatch(actions.selectMultiple(allComponentIds));
            this.showToast(`Selected ${allComponentIds.length} component(s)`, 'info');
        }
    }

    /**
     * Toggle fixed state for selected components or zones
     */
    toggleFixSelected() {
        const state = this.store.getState();

        // Handle zone fixing
        if (state.ui.selection.type === 'zone' && state.ui.selection.selectedIds.length > 0) {
            state.ui.selection.selectedIds.forEach(fullId => {
                const [type, id] = fullId.split(':');

                if (type === 'mounting') {
                    const zone = state.constraints.mountingZone;
                    if (zone) {
                        const newFixed = !zone.isFixed;
                        this.store.dispatch(actions.updateMountingZone({ isFixed: newFixed }));
                        this.showToast(`Mounting zone ${newFixed ? 'fixed' : 'unfixed'}`, 'info');
                    }
                } else if (type === 'keepout') {
                    const zone = state.constraints.keepOutZones.find(z => z.id === id);
                    if (zone) {
                        const newFixed = !zone.isFixed;
                        this.store.dispatch(actions.updateKeepOutZone(id, { isFixed: newFixed }));
                        this.showToast(`Keep-out zone ${newFixed ? 'fixed' : 'unfixed'}`, 'info');
                    }
                }
            });
            return;
        }

        // Handle component fixing
        if (state.ui.selection.type === 'component' && state.ui.selection.selectedIds.length > 0) {
            let fixedCount = 0;
            let unfixedCount = 0;

            state.ui.selection.selectedIds.forEach(id => {
                const component = state.components.get(id);
                if (component) {
                    const newFixed = !component.isFixed;
                    const newAngleFixed = !component.isAngleFixed;

                    this.store.dispatch(actions.updateComponent(id, {
                        isFixed: newFixed,
                        isAngleFixed: newAngleFixed
                    }));

                    if (newFixed) {
                        fixedCount++;
                    } else {
                        unfixedCount++;
                    }
                }
            });

            if (fixedCount > 0) {
                this.showToast(`Fixed ${fixedCount} component(s)`, 'info');
            } else if (unfixedCount > 0) {
                this.showToast(`Unfixed ${unfixedCount} component(s)`, 'info');
            }
        }
    }

    /**
     * Toggle mount zone enabled state for selected components
     */
    toggleMountZoneSelected() {
        const state = this.store.getState();

        if (state.ui.selection.type === 'component' && state.ui.selection.selectedIds.length > 0) {
            let enabledCount = 0;
            let disabledCount = 0;

            state.ui.selection.selectedIds.forEach(id => {
                const component = state.components.get(id);
                if (component) {
                    const currentEnabled = component.mountZone?.enabled || false;
                    const newEnabled = !currentEnabled;

                    // Ensure mountZone object exists
                    const updatedMountZone = {
                        ...(component.mountZone || {}),
                        enabled: newEnabled
                    };

                    this.store.dispatch(actions.updateComponent(id, {
                        mountZone: updatedMountZone
                    }));

                    if (newEnabled) {
                        enabledCount++;
                    } else {
                        disabledCount++;
                    }
                }
            });

            if (enabledCount > 0) {
                this.showToast(`Enabled mount zone for ${enabledCount} component(s)`, 'info');
            } else if (disabledCount > 0) {
                this.showToast(`Disabled mount zone for ${disabledCount} component(s)`, 'info');
            }
        }
    }

    /**
     * Rotate selected components by 90 degrees clockwise
     */
    rotateSelectedComponents(event) {
        const state = this.store.getState();

        // Handle zone rotation (45Â° increments)
        if (state.ui.selection.type === 'zone' && state.ui.selection.selectedIds.length > 0) {
            const angleDelta = event && event.shiftKey ? -45 : 45;
            let fixedCount = 0;
            let rotatedCount = 0;

            state.ui.selection.selectedIds.forEach(fullId => {
                const [type, id] = fullId.split(':');

                if (type === 'mounting') {
                    const zone = state.constraints.mountingZone;
                    if (zone) {
                        if (zone.isFixed) {
                            fixedCount++;
                        } else {
                            const newRotation = ((zone.rotation || 0) + angleDelta + 360) % 360;
                            this.store.dispatch(actions.updateMountingZone({ rotation: newRotation }));
                            rotatedCount++;
                        }
                    }
                } else if (type === 'keepout') {
                    const zone = state.constraints.keepOutZones.find(z => z.id === id);
                    if (zone) {
                        if (zone.isFixed) {
                            fixedCount++;
                        } else {
                            const newRotation = ((zone.rotation || 0) + angleDelta + 360) % 360;
                            this.store.dispatch(actions.updateKeepOutZone(id, { rotation: newRotation }));
                            rotatedCount++;
                        }
                    }
                }
            });

            // Show feedback for fixed zones
            if (fixedCount > 0 && rotatedCount === 0) {
                this.showToast('Cannot rotate: zone is fixed', 'warning');
            } else if (fixedCount > 0) {
                this.showToast(`Rotated ${rotatedCount} zone(s), ${fixedCount} fixed`, 'warning');
            }
            return;
        }

        // Only works for component selection
        if (state.ui.selection.type !== 'component' || state.ui.selection.selectedIds.length === 0) {
            return;
        }

        // Determine rotation angle: 90Â° clockwise, -90Â° with Shift
        const angleDelta = event && event.shiftKey ? -90 : 90;

        let fixedCount = 0;
        let rotatedCount = 0;

        state.ui.selection.selectedIds.forEach(id => {
            const component = state.components.get(id);
            if (component) {
                if (component.isAngleFixed) {
                    fixedCount++;
                } else {
                    // Regular rotation
                    const newAngle = (component.angle + angleDelta + 360) % 360;
                    this.store.dispatch(actions.updateComponent(id, { angle: newAngle }));
                    rotatedCount++;
                }
            }
        });

        // Show feedback
        if (fixedCount > 0 && rotatedCount === 0) {
            this.showToast('Cannot rotate: angle is fixed', 'warning');
        } else if (fixedCount > 0) {
            this.showToast(`Rotated ${rotatedCount} component(s), ${fixedCount} fixed`, 'warning');
        }
    }

    /**
     * Align selected components vertically (same X coordinate)
     * Aligns all selected components to the X position of the first selected component
     * and creates bidirectional alignment constraints
     */
    alignComponentsVertically() {
        const state = this.store.getState();

        if (state.ui.selection.selectedIds.length < 2) {
            return;
        }

        // Get the first selected component as the reference
        const referenceId = state.ui.selection.selectedIds[0];
        const referenceComponent = state.components.get(referenceId);

        if (!referenceComponent) return;

        const referenceX = referenceComponent.position.x;
        const selectedIds = [...state.ui.selection.selectedIds];
        let alignedCount = 0;

        // Align all other selected components to the reference X
        selectedIds.forEach(id => {
            if (id !== referenceId) {
                const component = state.components.get(id);
                if (component) {
                    this.store.dispatch(actions.moveComponent(id, { x: referenceX, y: component.position.y }));
                    alignedCount++;
                }
            }
        });

        // Create bidirectional alignment constraints between all selected components
        selectedIds.forEach(id => {
            const component = state.components.get(id);
            if (!component) return;

            // Add constraints to all other components in the selection
            const newConstraints = selectedIds
                .filter(otherId => otherId !== id)
                .map(otherId => ({ componentId: otherId, type: 'vertical' }));

            // Remove any existing vertical constraints with these components
            const existingConstraints = component.alignmentConstraints.filter(c =>
                c.type !== 'vertical' || !selectedIds.includes(c.componentId)
            );

            // Update the component with new constraints
            this.store.dispatch(actions.updateComponent(id, {
                alignmentConstraints: [...existingConstraints, ...newConstraints]
            }));
        });

        this.showToast(`Aligned ${alignedCount + 1} component(s) vertically`, 'success');
    }

    /**
     * Align selected components horizontally (same Y coordinate)
     * Aligns all selected components to the Y position of the first selected component
     * and creates bidirectional alignment constraints
     */
    alignComponentsHorizontally() {
        const state = this.store.getState();

        if (state.ui.selection.selectedIds.length < 2) {
            return;
        }

        // Get the first selected component as the reference
        const referenceId = state.ui.selection.selectedIds[0];
        const referenceComponent = state.components.get(referenceId);

        if (!referenceComponent) return;

        const referenceY = referenceComponent.position.y;
        const selectedIds = [...state.ui.selection.selectedIds];
        let alignedCount = 0;

        // Align all other selected components to the reference Y
        selectedIds.forEach(id => {
            if (id !== referenceId) {
                const component = state.components.get(id);
                if (component) {
                    this.store.dispatch(actions.moveComponent(id, { x: component.position.x, y: referenceY }));
                    alignedCount++;
                }
            }
        });

        // Create bidirectional alignment constraints between all selected components
        selectedIds.forEach(id => {
            const component = state.components.get(id);
            if (!component) return;

            // Add constraints to all other components in the selection
            const newConstraints = selectedIds
                .filter(otherId => otherId !== id)
                .map(otherId => ({ componentId: otherId, type: 'horizontal' }));

            // Remove any existing horizontal constraints with these components
            const existingConstraints = component.alignmentConstraints.filter(c =>
                c.type !== 'horizontal' || !selectedIds.includes(c.componentId)
            );

            // Update the component with new constraints
            this.store.dispatch(actions.updateComponent(id, {
                alignmentConstraints: [...existingConstraints, ...newConstraints]
            }));
        });

        this.showToast(`Aligned ${alignedCount + 1} component(s) horizontally`, 'success');
    }

    /**
     * Remove alignment constraint between two components (bidirectional)
     */
    removeAlignmentConstraint(componentId, constrainedId, constraintType) {
        const state = this.store.getState();

        // Remove constraint from both components
        [componentId, constrainedId].forEach(id => {
            const component = state.components.get(id);
            if (!component) return;

            const updatedConstraints = component.alignmentConstraints.filter(c =>
                !(c.componentId === (id === componentId ? constrainedId : componentId) && c.type === constraintType)
            );

            this.store.dispatch(actions.updateComponent(id, {
                alignmentConstraints: updatedConstraints
            }));
        });

        this.showToast('Alignment constraint removed', 'success');
    }

    /**
     * Remove all alignment constraints from selected components
     */
    unconstrainSelectedComponents() {
        const state = this.store.getState();

        if (state.ui.selection.type !== 'component' || state.ui.selection.selectedIds.length === 0) {
            return;
        }

        let totalRemoved = 0;

        // For each selected component, remove all its alignment constraints
        state.ui.selection.selectedIds.forEach(componentId => {
            const component = state.components.get(componentId);
            if (!component || !component.alignmentConstraints || component.alignmentConstraints.length === 0) {
                return;
            }

            const constraintsToRemove = [...component.alignmentConstraints];
            totalRemoved += constraintsToRemove.length;

            // Remove constraints bidirectionally
            constraintsToRemove.forEach(constraint => {
                const otherComponent = state.components.get(constraint.componentId);
                if (otherComponent && otherComponent.alignmentConstraints) {
                    // Remove the reverse constraint from the other component
                    const updatedOtherConstraints = otherComponent.alignmentConstraints.filter(c =>
                        c.componentId !== componentId || c.type !== constraint.type
                    );
                    this.store.dispatch(actions.updateComponent(constraint.componentId, {
                        alignmentConstraints: updatedOtherConstraints
                    }));
                }
            });

            // Clear all constraints from this component
            this.store.dispatch(actions.updateComponent(componentId, {
                alignmentConstraints: []
            }));
        });

        if (totalRemoved > 0) {
            const componentText = state.ui.selection.selectedIds.length === 1 ? 'component' : 'components';
            this.showToast(`Removed ${totalRemoved} constraint(s) from ${state.ui.selection.selectedIds.length} ${componentText}`, 'success');
        } else {
            this.showToast('No constraints to remove', 'info');
        }
    }

    /**
     * Create a direct beam segment between two components
     */
    createDirectBeamSegment(sourceId, targetId) {
        const state = this.store.getState();
        const source = state.components.get(sourceId);
        const target = state.components.get(targetId);

        if (!source || !target) return null;

        const beamAngle = BeamPhysics.calculateBeamAngle(source.position, target.position);
        const beamDirection = BeamPhysics.angleToVector(beamAngle);
        const pathLength = Math.sqrt(
            Math.pow(target.position.x - source.position.x, 2) +
            Math.pow(target.position.y - source.position.y, 2)
        );

        return new BeamSegment({
            sourceId: sourceId,
            targetId: targetId,
            sourcePort: 'output',
            targetPort: 'input',
            direction: beamDirection,
            directionAngle: beamAngle,
            pathLength: pathLength,
            autoCreated: true,
            isPersistent: true
        });
    }

    /**
     * Remove a path length constraint between two components
     */
    removePathLengthConstraint(sourceId, targetId) {
        const state = this.store.getState();
        const source = state.components.get(sourceId);
        const target = state.components.get(targetId);

        if (!source || !target) return;

        // Remove constraint from source
        if (source.pathLengthConstraints) {
            const sourceConstraints = source.pathLengthConstraints.filter(
                c => c.targetComponentId !== targetId
            );
            this.store.dispatch(actions.updateComponent(sourceId, {
                pathLengthConstraints: sourceConstraints
            }));
        }

        // Remove constraint from target
        if (target.pathLengthConstraints) {
            const targetConstraints = target.pathLengthConstraints.filter(
                c => c.targetComponentId !== sourceId
            );
            this.store.dispatch(actions.updateComponent(targetId, {
                pathLengthConstraints: targetConstraints
            }));
        }

        this.showToast('Path length constraint removed', 'success');
    }

    /**
     * Change fold count for a path length constraint
     * This will create/remove mirrors and recalculate geometry
     */
    changeFoldCount(sourceId, targetId, newFoldCount) {
        const state = this.store.getState();
        const source = state.components.get(sourceId);
        const target = state.components.get(targetId);

        if (!source || !target) {
            this.showToast('Components not found', 'error');
            return;
        }

        // Find the constraint
        const sourceConstraint = source.pathLengthConstraints?.find(c => c.targetComponentId === targetId);
        if (!sourceConstraint || sourceConstraint.mode !== 'foldable') {
            this.showToast('Constraint not found', 'error');
            return;
        }

        const oldFoldCount = sourceConstraint.foldCount || 0;
        if (oldFoldCount === newFoldCount) return; // No change

        // Update both constraints with new fold count
        const updatedSourceConstraints = source.pathLengthConstraints.map(c => {
            if (c.targetComponentId === targetId) {
                return { ...c, foldCount: newFoldCount };
            }
            return c;
        });

        const updatedTargetConstraints = target.pathLengthConstraints.map(c => {
            if (c.targetComponentId === sourceId) {
                return { ...c, foldCount: newFoldCount };
            }
            return c;
        });

        this.store.dispatch(actions.updateComponent(sourceId, {
            pathLengthConstraints: updatedSourceConstraints
        }));

        this.store.dispatch(actions.updateComponent(targetId, {
            pathLengthConstraints: updatedTargetConstraints
        }));

        // Phase 3 & 4: Create/remove mirrors and calculate positions
        this.updateMirrorsForConstraint(sourceId, targetId, newFoldCount);

        this.showToast(`Fold count changed to ${newFoldCount}`, 'success');
    }

    /**
     * Create/remove mirrors and calculate positions for a fold constraint
     */
    updateMirrorsForConstraint(sourceId, targetId, foldCount) {
        const state = this.store.getState();
        const source = state.components.get(sourceId);
        const target = state.components.get(targetId);

        if (!source || !target) return;

        const sourceConstraint = source.pathLengthConstraints?.find(c => c.targetComponentId === targetId);
        if (!sourceConstraint) return;

        // Delete old mirrors
        const oldMirrorIds = sourceConstraint.mirrorIds || [];
        oldMirrorIds.forEach(mirrorId => {
            this.store.dispatch(actions.deleteComponent(mirrorId));
        });

        // Create new mirrors based on fold count
        const newMirrorIds = [];
        const pathLength = sourceConstraint.targetPathLength;

        if (foldCount === 0) {
            // No mirrors, restore lenses to original H/V alignment
            // Determine alignment based on positions
            const dx = target.position.x - source.position.x;
            const dy = target.position.y - source.position.y;

            // Restore original angles based on alignment
            if (Math.abs(dx) > Math.abs(dy)) {
                // Horizontal alignment
                this.store.dispatch(actions.updateComponent(sourceId, {
                    angle: dx > 0 ? 0 : 180
                }));
                this.store.dispatch(actions.updateComponent(targetId, {
                    angle: dx > 0 ? 0 : 180
                }));
            } else {
                // Vertical alignment
                this.store.dispatch(actions.updateComponent(sourceId, {
                    angle: dy > 0 ? 90 : 270
                }));
                this.store.dispatch(actions.updateComponent(targetId, {
                    angle: dy > 0 ? 90 : 270
                }));
            }

            // Create direct beam segment
            this.createBeamSegmentsForFoldPath(sourceId, targetId);
        } else if (foldCount === 1) {
            // 1 mirror: L-shaped path
            // Calculate mirror position and angles
            const geometry = this.calculateOneFoldGeometry(source, target, pathLength);

            if (geometry) {
                // Create mirror
                const mirror = new Component({
                    type: ComponentType.MIRROR,
                    position: geometry.mirrorPosition,
                    angle: geometry.mirrorAngle,
                    name: `M_${source.name}_${target.name}`
                });

                this.store.dispatch(actions.addComponent(mirror));
                newMirrorIds.push(mirror.id);

                // Move and rotate lenses to match fold geometry
                this.store.dispatch(actions.updateComponent(sourceId, {
                    angle: geometry.sourceAngle
                }));
                this.store.dispatch(actions.updateComponent(targetId, {
                    position: geometry.targetPosition,
                    angle: geometry.targetAngle
                }));

                // Create beam segments to visualize path
                this.createBeamSegmentsForFoldPath(sourceId, mirror.id, targetId);
            }
        } else if (foldCount === 2) {
            // 2 mirrors: Z-shaped path
            const geometry = this.calculateTwoFoldGeometry(source, target, pathLength);

            if (geometry) {
                // Create first mirror
                const mirror1 = new Component({
                    type: ComponentType.MIRROR,
                    position: geometry.mirror1Position,
                    angle: geometry.mirror1Angle,
                    name: `M1_${source.name}_${target.name}`
                });

                this.store.dispatch(actions.addComponent(mirror1));
                newMirrorIds.push(mirror1.id);

                // Create second mirror
                const mirror2 = new Component({
                    type: ComponentType.MIRROR,
                    position: geometry.mirror2Position,
                    angle: geometry.mirror2Angle,
                    name: `M2_${source.name}_${target.name}`
                });

                this.store.dispatch(actions.addComponent(mirror2));
                newMirrorIds.push(mirror2.id);

                // Move and rotate lenses to match fold geometry
                this.store.dispatch(actions.updateComponent(sourceId, {
                    angle: geometry.sourceAngle
                }));
                this.store.dispatch(actions.updateComponent(targetId, {
                    position: geometry.targetPosition,
                    angle: geometry.targetAngle
                }));

                // Create beam segments to visualize path
                this.createBeamSegmentsForFoldPath(sourceId, mirror1.id, mirror2.id, targetId);
            }
        }

        // Update constraint with new mirror IDs
        const freshState = this.store.getState();
        const freshSource = freshState.components.get(sourceId);
        const freshTarget = freshState.components.get(targetId);

        if (freshSource) {
            const updatedSourceConstraints = freshSource.pathLengthConstraints.map(c => {
                if (c.targetComponentId === targetId) {
                    return { ...c, mirrorIds: newMirrorIds };
                }
                return c;
            });

            this.store.dispatch(actions.updateComponent(sourceId, {
                pathLengthConstraints: updatedSourceConstraints
            }));
        }

        if (freshTarget) {
            const updatedTargetConstraints = freshTarget.pathLengthConstraints.map(c => {
                if (c.targetComponentId === sourceId) {
                    return { ...c, mirrorIds: newMirrorIds };
                }
                return c;
            });

            this.store.dispatch(actions.updateComponent(targetId, {
                pathLengthConstraints: updatedTargetConstraints
            }));
        }
    }

    /**
     * Create beam segments to visualize fold path
     */
    createBeamSegmentsForFoldPath(...componentIds) {
        // componentIds can be: [source, mirror, target] for 1 fold
        // or [source, mirror1, mirror2, target] for 2 folds

        const state = this.store.getState();

        // Remove any existing beam segments between these components
        const idsSet = new Set(componentIds);
        state.beamPath.getAllSegments().forEach(seg => {
            if (idsSet.has(seg.sourceId) || idsSet.has(seg.targetId)) {
                this.store.dispatch(actions.deleteBeamSegment(seg.id));
            }
        });

        // Create new segments connecting components in sequence
        for (let i = 0; i < componentIds.length - 1; i++) {
            const sourceId = componentIds[i];
            const targetId = componentIds[i + 1];

            const sourceComp = state.components.get(sourceId);
            const targetComp = state.components.get(targetId);

            if (!sourceComp || !targetComp) continue;

            // Calculate segment
            const segment = this.createDirectBeamSegment(sourceId, targetId);
            if (segment) {
                this.store.dispatch(actions.addBeamSegment(segment));
            }
        }
    }

    /**
     * Calculate geometry for 1 fold (L-shaped path)
     */
    calculateOneFoldGeometry(source, target, pathLength) {
        // For 1 fold: L-shaped path with 90Â° turn at mirror
        // Key insight: For an L, if source is horizontal, beam goes right then turns 90Â° up/down

        const dx = target.position.x - source.position.x;
        const dy = target.position.y - source.position.y;

        // Determine if we're primarily horizontal or vertical
        const isHorizontalMajor = Math.abs(dx) > Math.abs(dy);

        let sourceAngle, mirrorPos, afterReflectionAngle, mirrorAngle, targetAngle;

        if (isHorizontalMajor) {
            // Horizontal then vertical L-shape
            // Source points right (0Â°) or left (180Â°)
            sourceAngle = dx > 0 ? 0 : 180;

            // Split path length in half for each segment
            const horizontalDist = pathLength / 2;
            const verticalDist = pathLength / 2;

            // Mirror at the corner of the L
            mirrorPos = {
                x: source.position.x + (dx > 0 ? horizontalDist : -horizontalDist),
                y: source.position.y
            };

            // Beam turns 90Â° (up or down based on target position)
            afterReflectionAngle = dy > 0 ? 90 : 270;

            // Mirror at 45Â° to create 90Â° reflection
            mirrorAngle = dx > 0 ? (dy > 0 ? 45 : 315) : (dy > 0 ? 135 : 225);

            // Target lens position at end of vertical segment
            const targetPos = {
                x: mirrorPos.x,
                y: mirrorPos.y + (dy > 0 ? verticalDist : -verticalDist)
            };

            // Target lens faces INCOMING beam
            targetAngle = (afterReflectionAngle + 180) % 360;

            return {
                mirrorPosition: mirrorPos,
                mirrorAngle: mirrorAngle,
                sourceAngle: sourceAngle,
                targetAngle: targetAngle,
                targetPosition: targetPos
            };

        } else {
            // Vertical then horizontal L-shape
            // Source points up (90Â°) or down (270Â°)
            sourceAngle = dy > 0 ? 90 : 270;

            const verticalDist = pathLength / 2;
            const horizontalDist = pathLength / 2;

            // Mirror at the corner of the L
            mirrorPos = {
                x: source.position.x,
                y: source.position.y + (dy > 0 ? verticalDist : -verticalDist)
            };

            // Beam turns 90Â° (left or right based on target position)
            afterReflectionAngle = dx > 0 ? 0 : 180;

            // Mirror at 45Â° to create 90Â° reflection
            mirrorAngle = dy > 0 ? (dx > 0 ? 45 : 135) : (dx > 0 ? 315 : 225);

            // Target lens position at end of horizontal segment
            const targetPos = {
                x: mirrorPos.x + (dx > 0 ? horizontalDist : -horizontalDist),
                y: mirrorPos.y
            };

            // Target lens faces INCOMING beam
            targetAngle = (afterReflectionAngle + 180) % 360;

            return {
                mirrorPosition: mirrorPos,
                mirrorAngle: mirrorAngle,
                sourceAngle: sourceAngle,
                targetAngle: targetAngle,
                targetPosition: targetPos
            };
        }
    }

    /**
     * Rotate entire constraint system as a rigid body
     * Rotates both lenses + all mirrors around the center point
     */
    rotateConstraintSystemRigidBody(componentId, angleDelta) {
        const state = this.store.getState();
        const component = state.components.get(componentId);

        if (!component) return;

        // Find foldable constraint
        const constraint = component.pathLengthConstraints?.find(c => c.mode === 'foldable');
        if (!constraint) return;

        const partner = state.components.get(constraint.targetComponentId);
        if (!partner) return;

        // Calculate rotation center (midpoint between lenses)
        const centerX = (component.position.x + partner.position.x) / 2;
        const centerY = (component.position.y + partner.position.y) / 2;

        const angleDeltaRad = angleDelta * Math.PI / 180;
        const cosAngle = Math.cos(angleDeltaRad);
        const sinAngle = Math.sin(angleDeltaRad);

        // Collect all components to rotate
        const componentsToRotate = [
            { id: componentId, comp: component },
            { id: constraint.targetComponentId, comp: partner }
        ];

        // Add mirrors
        (constraint.mirrorIds || []).forEach(mirrorId => {
            const mirror = state.components.get(mirrorId);
            if (mirror) {
                componentsToRotate.push({ id: mirrorId, comp: mirror });
            }
        });

        // Rotate each component
        componentsToRotate.forEach(({ id, comp }) => {
            // Translate to origin
            const relX = comp.position.x - centerX;
            const relY = comp.position.y - centerY;

            // Rotate
            const rotatedX = relX * cosAngle - relY * sinAngle;
            const rotatedY = relX * sinAngle + relY * cosAngle;

            // Translate back
            const newPos = {
                x: rotatedX + centerX,
                y: rotatedY + centerY
            };

            // Rotate angle
            const newAngle = (comp.angle + angleDelta + 360) % 360;

            this.store.dispatch(actions.updateComponent(id, {
                position: newPos,
                angle: newAngle
            }));
        });
    }

    /**
     * Calculate geometry for 2 folds (U-shaped path)
     */
    calculateTwoFoldGeometry(source, target, pathLength) {
        // For 2 folds: U-shaped path with two 90Â° turns
        // Beam goes out, turns 90Â°, travels across, turns 90Â° back toward source
        // Lenses end up parallel facing OPPOSITE directions (180Â° apart)

        const dx = target.position.x - source.position.x;
        const dy = target.position.y - source.position.y;

        // Determine if we're primarily horizontal or vertical
        const isHorizontalMajor = Math.abs(dx) > Math.abs(dy);

        // Divide into 3 equal segments
        const segmentLength = pathLength / 3;

        let sourceAngle, mirror1Pos, mirror2Pos, targetPos, mirror1Angle, mirror2Angle, targetAngle;

        if (isHorizontalMajor) {
            // Horizontal U-shape: go right, up, back left (or mirrored)
            sourceAngle = dx > 0 ? 0 : 180;

            // First mirror at end of first horizontal segment
            mirror1Pos = {
                x: source.position.x + (dx > 0 ? segmentLength : -segmentLength),
                y: source.position.y
            };

            // Second mirror at end of vertical segment
            const verticalDir = dy > 0 ? 1 : -1;
            mirror2Pos = {
                x: mirror1Pos.x,
                y: mirror1Pos.y + verticalDir * segmentLength
            };

            // Target at end of final horizontal segment (back toward source)
            targetPos = {
                x: mirror2Pos.x + (dx > 0 ? -segmentLength : segmentLength),
                y: mirror2Pos.y
            };

            // Mirror angles for 90Â° reflections
            mirror1Angle = dx > 0 ? (dy > 0 ? 45 : 315) : (dy > 0 ? 135 : 225);
            mirror2Angle = dx > 0 ? (dy > 0 ? 135 : 225) : (dy > 0 ? 45 : 315);

            // Target lens faces OPPOSITE to source (180Â° different)
            targetAngle = (sourceAngle + 180) % 360;

        } else {
            // Vertical U-shape: go up, right, back down (or mirrored)
            sourceAngle = dy > 0 ? 90 : 270;

            // First mirror at end of first vertical segment
            mirror1Pos = {
                x: source.position.x,
                y: source.position.y + (dy > 0 ? segmentLength : -segmentLength)
            };

            // Second mirror at end of horizontal segment
            const horizontalDir = dx > 0 ? 1 : -1;
            mirror2Pos = {
                x: mirror1Pos.x + horizontalDir * segmentLength,
                y: mirror1Pos.y
            };

            // Target at end of final vertical segment (back toward source)
            targetPos = {
                x: mirror2Pos.x,
                y: mirror2Pos.y + (dy > 0 ? -segmentLength : segmentLength)
            };

            // Mirror angles for 90Â° reflections
            mirror1Angle = dy > 0 ? (dx > 0 ? 45 : 135) : (dx > 0 ? 315 : 225);
            mirror2Angle = dy > 0 ? (dx > 0 ? 315 : 225) : (dx > 0 ? 45 : 135);

            // Target lens faces OPPOSITE to source (180Â° different)
            targetAngle = (sourceAngle + 180) % 360;
        }

        return {
            mirror1Position: mirror1Pos,
            mirror1Angle: mirror1Angle,
            mirror2Position: mirror2Pos,
            mirror2Angle: mirror2Angle,
            sourceAngle: sourceAngle,
            targetAngle: targetAngle,
            targetPosition: targetPos
        };
    }

    /**
     * Calculate path length between selected components (for UI display)
     */
    getPathLengthBetween(sourceId, targetId) {
        const state = this.store.getState();
        return state.beamPath.calculatePathLengthBetween(sourceId, targetId);
    }

    /**
     * Zoom by factor
     */
    zoom(factor) {
        const state = this.store.getState();
        const newZoom = Math.max(0.1, Math.min(10, state.ui.viewport.zoom * factor));
        this.store.dispatch(actions.setViewport({ zoom: newZoom }));

        // Update zoom display
        document.getElementById('zoom-level').textContent = Math.round(newZoom * 100) + '%';
        document.getElementById('zoom-percent').textContent = Math.round(newZoom * 100) + '%';
    }

    /**
     * Zoom to fit workspace
     */
    zoomFit() {
        const state = this.store.getState();
        const workspace = state.constraints.workspace;

        const canvasWidth = this.renderer.width;
        const canvasHeight = this.renderer.height;

        const zoomX = (canvasWidth - 100) / workspace.width;
        const zoomY = (canvasHeight - 100) / workspace.height;
        const zoom = Math.min(zoomX, zoomY, 2);

        this.store.dispatch(actions.setViewport({ zoom, panX: 0, panY: 0 }));

        document.getElementById('zoom-level').textContent = Math.round(zoom * 100) + '%';
        document.getElementById('zoom-percent').textContent = Math.round(zoom * 100) + '%';
    }

    /**
     * Undo last action
     */
    undo() {
        this.store.undo();
    }

    /**
     * Redo last undone action
     */
    redo() {
        this.store.redo();
    }

    /**
     * Create new document
     */
    newDocument() {
        if (this.store.getState().document.isDirty) {
            if (!confirm('You have unsaved changes. Create new document anyway?')) {
                return;
            }
        }
        this.store.dispatch(actions.newDocument());

        // Update file name input to match new document
        const fileNameInput = document.getElementById('file-name-input');
        if (fileNameInput) {
            const state = this.store.getState();
            fileNameInput.value = state.document.name || 'beam-path';
        }

        this.zoomFit();
    }

    /**
     * Open document from JSON file
     */
    openDocument() {
        // Check for unsaved changes
        if (this.store.getState().document.isDirty) {
            if (!confirm('You have unsaved changes. Open a new file anyway?')) {
                return;
            }
        }

        const input = document.getElementById('file-input');
        input.click();
        input.onchange = async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            try {
                const text = await file.text();
                const json = JSON.parse(text);

                // Validate format version
                if (!json.formatVersion) {
                    throw new Error('Invalid file format: missing formatVersion');
                }

                // Check for version migration
                const currentVersion = APP_VERSION.toFileFormat();
                const fileVersion = json.formatVersion;

                let shouldLoad = true;

                if (needsMigration(fileVersion, currentVersion)) {
                    // Format versions for display (e.g., "1.1.0" -> "V1.1")
                    const formatVersionForDisplay = (v) => {
                        const match = v.match(/(\d+)\.(\d+)/);
                        return match ? `V${match[1]}.${match[2]}` : v;
                    };

                    const fileVersionDisplay = formatVersionForDisplay(fileVersion);
                    const currentVersionDisplay = APP_VERSION.toString();

                    // Ask if user wants to upgrade
                    const shouldUpgrade = confirm(
                        `This file was created with an older version (${fileVersionDisplay}).\n\n` +
                        `Current version: ${currentVersionDisplay}\n\n` +
                        `Would you like to update it to the current format?\n\n` +
                        `Your original file will be saved and appended with "-${fileVersionDisplay}".\n` +
                        `The updated version will have the original file name.\n\n` +
                        `Click OK to upgrade, or Cancel for more options.`
                    );

                    if (shouldUpgrade) {
                        console.log(`Migrating file from ${fileVersion} to ${currentVersion}`);

                        // Create backup of original file
                        this.createBackupFile(file, fileVersionDisplay, text);

                        json.formatVersion = currentVersion;
                    } else {
                        // User clicked Cancel - ask if they want to use old version
                        const useOldVersion = confirm(
                            `Would you like to use the old file version (${fileVersionDisplay}) without upgrading?\n\n` +
                            `Click OK to load the old version as-is.\n` +
                            `Click Cancel to abort loading.`
                        );

                        if (useOldVersion) {
                            console.log(`Loading file with old version ${fileVersion} without upgrading`);
                        } else {
                            console.log('File loading cancelled by user');
                            shouldLoad = false;
                        }
                    }
                }

                // Only continue loading if user didn't cancel
                if (!shouldLoad) {
                    input.value = '';
                    return;
                }

                // Reconstruct components as a Map
                const components = new Map();
                if (json.components && Array.isArray(json.components)) {
                    json.components.forEach(compJson => {
                        const component = Component.fromJSON(compJson);
                        components.set(component.id, component);
                    });
                }

                // Reconstruct beam path
                const beamPath = json.beamPaths
                    ? BeamPath.fromJSON(json.beamPaths)
                    : new BeamPath();

                // Reconstruct constraints
                const constraints = {
                    workspace: json.workspace || { width: 600, height: 600 },
                    keepOutZones: json.constraints?.keepOutZones || [],
                    mountingZone: json.constraints?.mountingZone || null
                };

                // Build the new state (merge with defaults for missing properties)
                const newState = {
                    components,
                    beamPath,
                    constraints,
                    document: {
                        name: json.document?.name || file.name.replace('.json', ''),
                        description: json.document?.description || '',
                        createdAt: json.document?.createdAt || new Date().toISOString(),
                        modifiedAt: json.document?.modifiedAt || new Date().toISOString(),
                        isDirty: false
                    },
                    ui: {
                        tool: 'select',
                        viewport: { zoom: 1, panX: 0, panY: 0 },
                        selection: {
                            type: null,
                            selectedIds: [],
                            selectedZoneId: null,
                            selectedSegmentIds: [],
                            hoveredId: null,
                            hoveredZoneId: null,
                            hoveredSegmentId: null
                        },
                        selectionBox: null,
                        placingComponent: null,
                        connectingFrom: null,
                        labelsVisible: json.ui?.labelsVisible ?? true,
                        autoPropagate: json.ui?.autoPropagate ?? false
                    },
                    grid: json.grid || {
                        enabled: true,
                        visible: false,
                        size: 25
                    },
                    background: json.background || {
                        type: 'color',
                        color: '#0d1117',
                        imagePath: null,
                        imageData: null,
                        imageDataURL: null,
                        opacity: 100
                    },
                    wavelengths: json.wavelengths || [
                        { id: 'w1', name: '633nm HeNe', color: '#ff0000', isPreset: true },
                        { id: 'w2', name: '532nm Nd:YAG', color: '#00ff00', isPreset: true },
                        { id: 'w3', name: '1064nm IR', color: '#ff00ff', isPreset: true },
                        { id: 'w4', name: '405nm Violet', color: '#8800ff', isPreset: true },
                        { id: 'w5', name: '780nm GaAs', color: '#cc0044', isPreset: true },
                        { id: 'w6', name: '850nm VCSEL', color: '#990066', isPreset: true }
                    ],
                    activeWavelengthId: json.activeWavelengthId || 'w1',
                    calculated: {
                        centerOfMass: null,
                        totalMass: 0,
                        isCoMInMountingZone: false,
                        constraintViolations: [],
                        totalPathLength: 0
                    }
                };

                // Load the document
                this.store.dispatch(actions.loadDocument(newState));

                // Recreate background image from data URL if present
                if (newState.background && newState.background.imageDataURL) {
                    const img = new Image();
                    img.onload = () => {
                        this.store.dispatch(actions.setBackground({
                            ...newState.background,
                            imageData: img
                        }));
                        this.render();
                    };
                    img.src = newState.background.imageDataURL;
                }

                // Recalculate derived values
                this.store.dispatch(actions.recalculate());

                // Update workspace size inputs in UI
                document.getElementById('workspace-width').value = constraints.workspace.width;
                document.getElementById('workspace-height').value = constraints.workspace.height;

                // Update file name input
                const fileNameInput = document.getElementById('file-name-input');
                if (fileNameInput) {
                    fileNameInput.value = newState.document.name || 'beam-path';
                }

                // Reset view
                this.zoomFit();
                this.updateUI();
                this.render();

                console.log('Loaded document:', json.document?.name || file.name);
            } catch (err) {
                console.error('Failed to load file:', err);
                alert('Failed to load file: ' + err.message);
            }

            // Reset file input so same file can be selected again
            input.value = '';
        };
    }

    /**
     * Create backup file with version suffix
     * @param {File} originalFile - The original file object
     * @param {string} versionDisplay - Version string for display (e.g., "V1.1")
     * @param {string} fileContent - The file content to backup
     */
    createBackupFile(originalFile, versionDisplay, fileContent) {
        // Extract filename without extension
        const originalName = originalFile.name;
        const lastDot = originalName.lastIndexOf('.');
        const baseName = lastDot > 0 ? originalName.substring(0, lastDot) : originalName;
        const extension = lastDot > 0 ? originalName.substring(lastDot) : '.json';

        // Create backup filename with version suffix
        const backupFileName = `${baseName}-${versionDisplay}${extension}`;

        // Create blob and download link
        const blob = new Blob([fileContent], { type: 'application/json' });
        const url = URL.createObjectURL(blob);

        const a = window.document.createElement('a');
        a.href = url;
        a.download = backupFileName;
        a.click();

        URL.revokeObjectURL(url);

        console.log(`Created backup: ${backupFileName}`);
    }

    /**
     * Save document (placeholder)
     */
    saveDocument() {
        const state = this.store.getState();

        const document = {
            formatVersion: APP_VERSION.toFileFormat(),
            appVersion: APP_VERSION.toString(),
            document: state.document,
            workspace: state.constraints.workspace,
            components: Array.from(state.components.values()).map(c => c.toJSON()),
            beamPaths: state.beamPath.toJSON(),
            constraints: {
                keepOutZones: state.constraints.keepOutZones,
                mountingZone: state.constraints.mountingZone
            },
            ui: {
                labelsVisible: state.ui.labelsVisible,
                autoPropagate: state.ui.autoPropagate
            },
            grid: state.grid,
            background: {
                type: state.background.type,
                color: state.background.color,
                imagePath: state.background.imagePath,
                imageDataURL: state.background.imageDataURL, // Save data URL for persistence
                opacity: state.background.opacity
                // Note: imageData (Image object) is runtime only, not saved
            },
            wavelengths: state.wavelengths,
            activeWavelengthId: state.activeWavelengthId
        };

        const json = JSON.stringify(document, null, 2);
        const blob = new Blob([json], { type: 'application/json' });
        const url = URL.createObjectURL(blob);

        const a = window.document.createElement('a');
        a.href = url;
        // Get filename from the file name input
        const fileNameInput = window.document.getElementById('file-name-input');
        const fileName = fileNameInput?.value.trim() || state.document.name || 'beam-path';
        a.download = fileName + '.json';
        a.click();

        URL.revokeObjectURL(url);
        this.store.dispatch(actions.markClean());
    }

    /**
     * Update UI based on state
     */
    updateUI() {
        const state = this.store.getState();

        // Update auto-propagate checkbox
        const autoPropagateCheckbox = document.getElementById('auto-propagate-beams');
        if (autoPropagateCheckbox) {
            autoPropagateCheckbox.checked = state.ui.autoPropagate;
        }

        // Update status bar
        const com = state.calculated.centerOfMass;
        document.getElementById('com-position').textContent =
            com ? `(${com.x.toFixed(1)}, ${com.y.toFixed(1)})` : '(-, -)';

        const mountStatus = document.getElementById('mount-status');
        if (!state.constraints.mountingZone) {
            mountStatus.textContent = 'Not defined';
            mountStatus.className = 'status-value';
        } else if (state.calculated.isCoMInMountingZone) {
            mountStatus.textContent = 'OK';
            mountStatus.className = 'status-value ok';
        } else {
            mountStatus.textContent = 'OUTSIDE';
            mountStatus.className = 'status-value fail';
        }

        const violations = state.calculated.constraintViolations.length;
        const violationCount = document.getElementById('violation-count');
        violationCount.textContent = violations.toString();
        violationCount.className = violations > 0 ? 'status-value has-violations' : 'status-value';

        document.getElementById('component-count').textContent = state.components.size.toString();

        // Update property panel
        const selectedId = state.ui.selection.selectedIds[0];
        const selectedZoneId = state.ui.selection.selectedZoneId;
        const selectedSegmentIds = state.ui.selection.selectedSegmentIds || [];
        const selectionType = state.ui.selection.type;

        const noSelection = document.getElementById('no-selection');
        const componentProps = document.getElementById('component-properties');
        const zoneProps = document.getElementById('zone-properties');
        const segmentProps = document.getElementById('segment-properties');
        const selectionSection = document.getElementById('selection-info');
        const optimizerSection = document.getElementById('optimizer-section');

        // Hide all property panels first
        noSelection.classList.add('hidden');
        componentProps.classList.add('hidden');
        zoneProps.classList.add('hidden');
        segmentProps.classList.add('hidden');

        // Toggle between properties and optimizer sections
        const hasSelection = (selectionType === 'component' && selectedId && state.components.has(selectedId)) ||
                             (selectionType === 'zone' && selectedZoneId) ||
                             (selectionType === 'segment' && selectedSegmentIds.length > 0);

        const optimizerToggleContainer = document.getElementById('optimizer-toggle-container');

        if (hasSelection) {
            // Show properties section, hide optimizer toggle button
            selectionSection.classList.remove('hidden');
            if (optimizerToggleContainer) {
                optimizerToggleContainer.classList.add('hidden');
            }
        } else {
            // Hide properties section, show optimizer toggle button (only if optimizer section is hidden)
            selectionSection.classList.add('hidden');
            if (optimizerToggleContainer && optimizerSection.classList.contains('hidden')) {
                optimizerToggleContainer.classList.remove('hidden');
            }
        }

        if (selectionType === 'component' && selectedId && state.components.has(selectedId)) {
            // Show component properties
            const component = state.components.get(selectedId);

            componentProps.classList.remove('hidden');

            document.getElementById('prop-name').value = component.name;
            document.getElementById('prop-label-position').value = component.labelPosition || 'auto';
            document.getElementById('prop-label-visible').checked = component.labelVisible ?? true;

            // Label background color
            const labelBgColor = component.labelBackgroundColor || 'auto';
            const labelBgColorInput = document.getElementById('prop-label-bg-color');
            if (labelBgColorInput && labelBgColor !== 'auto') {
                labelBgColorInput.value = labelBgColor;
            }

            document.getElementById('prop-type').textContent = ComponentNames[component.type] || component.type;
            document.getElementById('prop-x').value = component.position.x.toFixed(1);
            document.getElementById('prop-y').value = component.position.y.toFixed(1);

            // Normalize angle to 0-180Â° range for display
            const displayAngle = component.angle > 180 ? component.angle % 180 : component.angle;
            document.getElementById('prop-angle').value = displayAngle;
            document.getElementById('prop-angle-slider').value = displayAngle;

            document.getElementById('prop-mass').value = component.mass;
            document.getElementById('prop-width').value = component.size.width;
            document.getElementById('prop-height').value = component.size.height;
            document.getElementById('prop-fixed').checked = component.isFixed;
            document.getElementById('prop-angle-fixed').checked = component.isAngleFixed;

            // Reflectance (only for relevant components)
            const opticalProps = document.getElementById('optical-properties');
            if (component.type === ComponentType.BEAM_SPLITTER) {
                opticalProps.classList.remove('hidden');
                document.getElementById('prop-reflectance-slider').value = component.reflectance * 100;
                document.getElementById('prop-reflectance-value').textContent = Math.round(component.reflectance * 100);
            } else {
                opticalProps.classList.add('hidden');
            }

            // Mount zone controls
            const mountEnabled = component.mountZone?.enabled || false;
            const mountPaddingX = component.mountZone?.paddingX ?? component.mountZone?.padding ?? 10;
            const mountPaddingY = component.mountZone?.paddingY ?? component.mountZone?.padding ?? 10;
            const mountOffsetX = component.mountZone?.offsetX ?? 0;
            const mountOffsetY = component.mountZone?.offsetY ?? 0;

            document.getElementById('prop-mount-enabled').checked = mountEnabled;
            document.getElementById('prop-mount-padding-x').value = mountPaddingX;
            document.getElementById('prop-mount-padding-y').value = mountPaddingY;
            document.getElementById('prop-mount-offset-x').value = mountOffsetX;
            document.getElementById('prop-mount-offset-y').value = mountOffsetY;

            const mountDetailsControls = document.getElementById('mount-details-controls');
            if (mountDetailsControls) {
                mountDetailsControls.style.display = mountEnabled ? 'flex' : 'none';
            }

            // === Beam Physics Controls ===

            // Emit light toggle (only for sources)
            const emitLightGroup = document.getElementById('emit-light-group');
            if (component.type === ComponentType.SOURCE) {
                emitLightGroup.style.display = 'block';
                document.getElementById('prop-emit-light').checked = component.emitLight !== false;
            } else {
                emitLightGroup.style.display = 'none';
            }

            // Shallow angle mode (only for beam splitters)
            const shallowAngleGroup = document.getElementById('shallow-angle-group');
            if (component.type === ComponentType.BEAM_SPLITTER) {
                shallowAngleGroup.style.display = 'block';
                document.getElementById('prop-shallow-enabled').checked = component.isShallowAngle || false;
                document.getElementById('prop-shallow-angle').value = component.shallowAngle || 5;
                document.getElementById('shallow-angle-controls').style.display =
                    component.isShallowAngle ? 'block' : 'none';
            } else {
                shallowAngleGroup.style.display = 'none';
            }

            // Grid snap toggle
            document.getElementById('prop-snap-grid').checked = component.snapToGrid !== false;

            // Allow any angle toggle
            document.getElementById('prop-allow-any-angle').checked = component.allowAnyAngle || false;

            // Path length constraints (for lenses and beam splitters)
            const pathConstraintGroup = document.getElementById('path-constraint-group');
            if (component.type === ComponentType.LENS || component.type === ComponentType.BEAM_SPLITTER) {
                pathConstraintGroup.style.display = 'block';

                const constraints = component.pathConstraints || {};
                const isEnabled = constraints.enabled || false;

                document.getElementById('prop-path-constraint-enabled').checked = isEnabled;
                document.getElementById('path-constraint-details').style.display = isEnabled ? 'block' : 'none';

                // Input distance
                const hasInputDist = constraints.inputDistance !== null && constraints.inputDistance !== undefined;
                document.getElementById('prop-fix-input-dist').checked = hasInputDist;
                document.getElementById('prop-input-distance').value = constraints.inputDistance || '';
                document.getElementById('prop-input-distance').disabled = !hasInputDist;

                // Output distance (for lenses only)
                const outputRow = document.getElementById('output-distance-row');
                if (component.type === ComponentType.LENS) {
                    outputRow.style.display = 'flex';
                    const hasOutputDist = constraints.outputDistance !== null && constraints.outputDistance !== undefined;
                    document.getElementById('prop-fix-output-dist').checked = hasOutputDist;
                    document.getElementById('prop-output-distance').value = constraints.outputDistance || '';
                    document.getElementById('prop-output-distance').disabled = !hasOutputDist;
                } else {
                    outputRow.style.display = 'none';
                }

                // Reflected distance (for beam splitters only)
                const reflectedRow = document.getElementById('reflected-distance-row');
                if (component.type === ComponentType.BEAM_SPLITTER) {
                    reflectedRow.style.display = 'flex';
                    const hasReflectedDist = constraints.reflectedDistance !== null && constraints.reflectedDistance !== undefined;
                    document.getElementById('prop-fix-reflected-dist').checked = hasReflectedDist;
                    document.getElementById('prop-reflected-distance').value = constraints.reflectedDistance || '';
                    document.getElementById('prop-reflected-distance').disabled = !hasReflectedDist;
                } else {
                    reflectedRow.style.display = 'none';
                }
            } else {
                pathConstraintGroup.style.display = 'none';
            }

            // Alignment Constraints
            const alignmentConstraintsList = document.getElementById('alignment-constraints-list');
            if (alignmentConstraintsList) {
                alignmentConstraintsList.innerHTML = '';

                if (component.alignmentConstraints && component.alignmentConstraints.length > 0) {
                    component.alignmentConstraints.forEach(constraint => {
                        const constrainedComp = state.components.get(constraint.componentId);
                        if (!constrainedComp) return; // Component might have been deleted

                        const item = document.createElement('div');
                        item.className = 'alignment-constraint-item';

                        const info = document.createElement('div');
                        info.className = 'alignment-constraint-info';

                        const type = document.createElement('span');
                        type.className = 'alignment-constraint-type';
                        type.textContent = constraint.type === 'vertical' ? 'â Vertical' : 'â Horizontal';

                        const compName = document.createElement('span');
                        compName.className = 'alignment-constraint-component';
                        compName.textContent = `with ${constrainedComp.name}`;

                        info.appendChild(type);
                        info.appendChild(compName);

                        const removeBtn = document.createElement('button');
                        removeBtn.className = 'alignment-constraint-remove';
                        removeBtn.textContent = 'Ã';
                        removeBtn.title = 'Remove constraint';
                        removeBtn.addEventListener('click', () => {
                            this.removeAlignmentConstraint(component.id, constraint.componentId, constraint.type);
                        });

                        item.appendChild(info);
                        item.appendChild(removeBtn);
                        alignmentConstraintsList.appendChild(item);
                    });
                } else {
                    const emptyMsg = document.createElement('div');
                    emptyMsg.className = 'alignment-constraints-empty';
                    emptyMsg.textContent = 'No alignment constraints';
                    alignmentConstraintsList.appendChild(emptyMsg);
                }
            }

            // Display path length constraints
            const pathLengthConstraintsList = document.getElementById('path-length-constraints-list');
            if (pathLengthConstraintsList) {
                pathLengthConstraintsList.innerHTML = '';

                if (component.pathLengthConstraints && component.pathLengthConstraints.length > 0) {
                    component.pathLengthConstraints.forEach(constraint => {
                        const targetComp = state.components.get(constraint.targetComponentId);
                        if (!targetComp) return; // Component might have been deleted

                        // Calculate current path length
                        const currentLength = state.beamPath.calculatePathLengthBetween(
                            component.id,
                            constraint.targetComponentId
                        );

                        // Determine status
                        let status = 'inactive';
                        let statusIcon = 'â';
                        if (currentLength !== null) {
                            const deviation = Math.abs(currentLength - constraint.targetPathLength);
                            const tolerance = constraint.tolerance || 1.0;
                            if (deviation <= tolerance) {
                                status = 'satisfied';
                                statusIcon = 'â';
                            } else {
                                status = 'violated';
                                statusIcon = 'â ';
                            }
                        }

                        const item = document.createElement('div');
                        item.className = `path-constraint-item ${status}`;

                        // Header
                        const header = document.createElement('div');
                        header.className = 'path-constraint-header';

                        const icon = document.createElement('span');
                        icon.className = 'path-constraint-icon';
                        icon.textContent = 'â';

                        const target = document.createElement('span');
                        target.className = 'path-constraint-target';
                        target.textContent = targetComp.name;

                        const removeBtn = document.createElement('button');
                        removeBtn.className = 'path-constraint-remove';
                        removeBtn.textContent = 'Ã';
                        removeBtn.title = 'Remove constraint';
                        removeBtn.addEventListener('click', () => {
                            this.removePathLengthConstraint(component.id, constraint.targetComponentId);
                        });

                        header.appendChild(icon);
                        header.appendChild(target);
                        header.appendChild(removeBtn);

                        // Details
                        const details = document.createElement('div');
                        details.className = 'path-constraint-details';

                        // Target length row
                        const targetRow = document.createElement('div');
                        targetRow.className = 'path-constraint-row';

                        const targetLabel = document.createElement('span');
                        targetLabel.className = 'path-constraint-label';
                        targetLabel.textContent = 'Target:';

                        const targetValue = document.createElement('span');
                        targetValue.className = 'path-constraint-value';
                        targetValue.textContent = `${constraint.targetPathLength.toFixed(1)} mm`;

                        targetRow.appendChild(targetLabel);
                        targetRow.appendChild(targetValue);

                        // Current length row
                        const currentRow = document.createElement('div');
                        currentRow.className = 'path-constraint-row';

                        const currentLabel = document.createElement('span');
                        currentLabel.className = 'path-constraint-label';
                        currentLabel.textContent = 'Current:';

                        const currentValue = document.createElement('span');
                        currentValue.className = `path-constraint-current ${status}`;
                        if (currentLength !== null) {
                            currentValue.textContent = `${currentLength.toFixed(1)} mm`;
                        } else {
                            currentValue.textContent = 'No path';
                        }

                        const statusIconSpan = document.createElement('span');
                        statusIconSpan.className = 'path-constraint-status-icon';
                        statusIconSpan.textContent = statusIcon;

                        currentValue.appendChild(statusIconSpan);
                        currentRow.appendChild(currentLabel);
                        currentRow.appendChild(currentValue);

                        details.appendChild(targetRow);
                        details.appendChild(currentRow);

                        // Fold count controls (NEW UI)
                        if (constraint.mode === 'foldable') {
                            const foldCountRow = document.createElement('div');
                            foldCountRow.className = 'path-constraint-row';
                            foldCountRow.style.marginTop = '8px';

                            const foldCountLabel = document.createElement('div');
                            foldCountLabel.textContent = 'Folds:';
                            foldCountLabel.style.fontSize = '11px';
                            foldCountLabel.style.marginBottom = '4px';
                            foldCountLabel.style.color = '#999';

                            const foldButtonGroup = document.createElement('div');
                            foldButtonGroup.style.display = 'flex';
                            foldButtonGroup.style.gap = '4px';

                            const currentFoldCount = constraint.foldCount || 0;

                            // Create buttons for 0, 1, 2 folds
                            [0, 1, 2].forEach(count => {
                                const btn = document.createElement('button');
                                btn.textContent = count.toString();
                                btn.className = 'fold-count-btn' + (currentFoldCount === count ? ' active' : '');
                                btn.style.flex = '1';
                                btn.style.padding = '4px 8px';
                                btn.style.fontSize = '12px';
                                btn.style.border = currentFoldCount === count ? '2px solid #4CAF50' : '1px solid #444';
                                btn.style.background = currentFoldCount === count ? '#4CAF5022' : '#222';
                                btn.style.color = currentFoldCount === count ? '#4CAF50' : '#999';
                                btn.style.borderRadius = '4px';
                                btn.style.cursor = 'pointer';
                                btn.title = `${count} fold${count !== 1 ? 's' : ''}`;

                                btn.addEventListener('click', () => {
                                    this.changeFoldCount(component.id, constraint.targetComponentId, count);
                                });

                                foldButtonGroup.appendChild(btn);
                            });

                            foldCountRow.appendChild(foldCountLabel);
                            foldCountRow.appendChild(foldButtonGroup);
                            details.appendChild(foldCountRow);

                            // Show mirror count if folds > 0
                            if (currentFoldCount > 0) {
                                const mirrorCountRow = document.createElement('div');
                                mirrorCountRow.className = 'path-constraint-row';
                                mirrorCountRow.style.fontSize = '11px';
                                mirrorCountRow.style.color = '#666';
                                mirrorCountRow.style.marginTop = '4px';

                                const mirrorCount = (constraint.mirrorIds || []).length;
                                mirrorCountRow.textContent = `${mirrorCount} mirror${mirrorCount !== 1 ? 's' : ''}`;

                                details.appendChild(mirrorCountRow);
                            }
                        }

                        item.appendChild(header);
                        item.appendChild(details);
                        pathLengthConstraintsList.appendChild(item);
                    });
                }
            }
        } else if (selectionType === 'zone' && selectedZoneId) {
            // Show zone properties
            let zone = null;
            let zoneType = '';

            if (selectedZoneId === 'mounting') {
                zone = state.constraints.mountingZone;
                zoneType = 'Mounting Zone';
            } else if (selectedZoneId.startsWith('keepout:')) {
                const id = selectedZoneId.replace('keepout:', '');
                zone = state.constraints.keepOutZones.find(z => z.id === id);
                zoneType = 'Keep-Out Zone';
            }

            if (zone) {
                zoneProps.classList.remove('hidden');

                document.getElementById('zone-prop-name').value = zone.name || '';
                document.getElementById('zone-prop-type').textContent = zoneType;
                document.getElementById('zone-prop-x').value = zone.bounds.x.toFixed(1);
                document.getElementById('zone-prop-y').value = zone.bounds.y.toFixed(1);
                document.getElementById('zone-prop-width').value = zone.bounds.width.toFixed(1);
                document.getElementById('zone-prop-height').value = zone.bounds.height.toFixed(1);

                // Active checkbox only for keep-out zones
                const activeGroup = document.getElementById('zone-active-group');
                if (selectedZoneId.startsWith('keepout:')) {
                    activeGroup.classList.remove('hidden');
                    document.getElementById('zone-prop-active').checked = zone.isActive;
                } else {
                    activeGroup.classList.add('hidden');
                }
            } else {
                noSelection.classList.remove('hidden');
            }
        } else if (selectionType === 'segment' && selectedSegmentIds.length > 0) {
            // Show segment properties
            const segmentId = selectedSegmentIds[0]; // For now, show first selected segment
            const segment = state.beamPath.segments.get(segmentId);

            if (segment) {
                segmentProps.classList.remove('hidden');

                // Get source and target component names
                const sourceComp = state.components.get(segment.sourceId);
                const targetComp = state.components.get(segment.targetId);

                document.getElementById('segment-prop-source').textContent = sourceComp ? sourceComp.name : 'Unknown';
                document.getElementById('segment-prop-target').textContent = targetComp ? targetComp.name : 'Unknown';
                document.getElementById('segment-prop-length').textContent = segment.pathLength.toFixed(1) + ' mm';

                // Populate wavelengths list
                this.updateSegmentWavelengthsList(segment, state.wavelengths);

                // Populate wavelength dropdown
                this.updateSegmentWavelengthDropdown(segment, state.wavelengths);
            } else {
                noSelection.classList.remove('hidden');
            }
        } else {
            noSelection.classList.remove('hidden');
        }

        // Update undo/redo buttons
        document.getElementById('btn-undo').disabled = !this.store.canUndo();
        document.getElementById('btn-redo').disabled = !this.store.canRedo();
    }

    /**
     * Update segment wavelengths list display
     */
    updateSegmentWavelengthsList(segment, wavelengths) {
        const listEl = document.getElementById('segment-wavelengths-list');
        if (!listEl) return;

        listEl.innerHTML = '';

        if (!segment.wavelengthIds || segment.wavelengthIds.length === 0) {
            listEl.innerHTML = '<div style="font-size: 11px; color: var(--text-secondary); padding: 8px;">No wavelengths</div>';
            return;
        }

        segment.wavelengthIds.forEach(wlId => {
            const wavelength = wavelengths.find(w => w.id === wlId);
            if (wavelength) {
                const item = document.createElement('div');
                item.className = 'segment-wavelength-item';
                item.innerHTML = `
                    <div class="swatch" style="background-color: ${wavelength.color}"></div>
                    <span class="name">${wavelength.name}</span>
                    <button class="remove-btn" data-wavelength-id="${wlId}" title="Remove">&times;</button>
                `;
                listEl.appendChild(item);

                // Add remove handler
                item.querySelector('.remove-btn').addEventListener('click', () => {
                    this.removeWavelengthFromSegment(segment.id, wlId);
                });
            }
        });
    }

    /**
     * Update segment wavelength dropdown
     */
    updateSegmentWavelengthDropdown(segment, wavelengths) {
        const selectEl = document.getElementById('segment-wavelength-select');
        if (!selectEl) return;

        // Clear existing options except first
        selectEl.innerHTML = '<option value="">Add wavelength...</option>';

        // Add wavelengths that are not already on the segment
        const segmentWavelengthIds = segment.wavelengthIds || [];
        wavelengths.forEach(wl => {
            if (!segmentWavelengthIds.includes(wl.id)) {
                const option = document.createElement('option');
                option.value = wl.id;
                option.textContent = wl.name;
                selectEl.appendChild(option);
            }
        });
    }

    /**
     * Remove a wavelength from the selected segment(s)
     */
    removeWavelengthFromSegment(segmentId, wavelengthId) {
        const state = this.store.getState();
        const segment = state.beamPath.segments.get(segmentId);
        if (!segment) return;

        const newWavelengthIds = segment.wavelengthIds.filter(id => id !== wavelengthId);
        this.store.dispatch(actions.updateSegmentWavelengths(segmentId, newWavelengthIds));
    }

    /**
     * Render the canvas
     */
    render() {
        const state = this.store.getState();

        // Check if we're in preview mode or split-screen mode
        if (this.isSplitScreenMode && this.previewSnapshot) {
            // Split-screen comparison: original vs selected
            const originalLayout = this.optimizer.getOriginalLayout();
            this.renderer.renderComparison(state, originalLayout, this.previewSnapshot);
        } else if (this.previewSnapshot) {
            // Preview mode: show snapshot with indicator
            this.renderer.renderPreview(state, this.previewSnapshot);
        } else {
            // Normal rendering
            this.renderer.render(state);
        }
    }

    /**
     * Calculate where a ray intersects the workspace boundary
     * @param {Object} origin - Ray origin position {x, y}
     * @param {number} angle - Ray direction angle (degrees)
     * @param {Object} workspace - Workspace bounds {width, height}
     * @returns {Object} Intersection point {x, y}
     */
    findWorkspaceBoundaryIntersection(origin, angle, workspace) {
        const rayDir = BeamPhysics.angleToVector(angle);

        // Calculate intersections with all four workspace boundaries
        const intersections = [];

        // Right boundary (x = workspace.width)
        if (rayDir.x > 0) {
            const t = (workspace.width - origin.x) / rayDir.x;
            const y = origin.y + t * rayDir.y;
            if (y >= 0 && y <= workspace.height && t > 0) {
                intersections.push({ x: workspace.width, y, distance: t });
            }
        }

        // Left boundary (x = 0)
        if (rayDir.x < 0) {
            const t = (0 - origin.x) / rayDir.x;
            const y = origin.y + t * rayDir.y;
            if (y >= 0 && y <= workspace.height && t > 0) {
                intersections.push({ x: 0, y, distance: t });
            }
        }

        // Bottom boundary (y = workspace.height)
        if (rayDir.y > 0) {
            const t = (workspace.height - origin.y) / rayDir.y;
            const x = origin.x + t * rayDir.x;
            if (x >= 0 && x <= workspace.width && t > 0) {
                intersections.push({ x, y: workspace.height, distance: t });
            }
        }

        // Top boundary (y = 0)
        if (rayDir.y < 0) {
            const t = (0 - origin.y) / rayDir.y;
            const x = origin.x + t * rayDir.x;
            if (x >= 0 && x <= workspace.width && t > 0) {
                intersections.push({ x, y: 0, distance: t });
            }
        }

        // Return the closest intersection
        if (intersections.length === 0) {
            // Shouldn't happen, but return a far point in the ray direction
            return {
                x: origin.x + rayDir.x * 1000,
                y: origin.y + rayDir.y * 1000
            };
        }

        intersections.sort((a, b) => a.distance - b.distance);
        return { x: intersections[0].x, y: intersections[0].y };
    }

    /**
     * Find the first component that a ray intersects
     * @param {Object} origin - Ray origin position {x, y}
     * @param {number} angle - Ray direction angle (degrees)
     * @param {string} excludeId - Component ID to exclude from search
     * @param {number} maxDistance - Maximum ray distance (workspace bounds)
     * @returns {Object|null} {component, distance} or null if no intersection
     */
    findRayComponentIntersection(origin, angle, excludeId, maxDistance) {
        const state = this.store.getState();
        const rayDir = BeamPhysics.angleToVector(angle);

        let closestComponent = null;
        let closestDistance = maxDistance;

        // Check each component for intersection
        for (const [id, component] of state.components) {
            if (id === excludeId) continue;

            // Calculate component bounds (axis-aligned bounding box)
            const hw = component.size.width / 2;
            const hh = component.size.height / 2;
            const cx = component.position.x;
            const cy = component.position.y;

            // Use a simple line-rectangle intersection test
            // We'll use a rotated rectangle if needed, but for simplicity start with AABB
            const bounds = {
                minX: cx - hw,
                maxX: cx + hw,
                minY: cy - hh,
                maxY: cy + hh
            };

            // Ray-AABB intersection test
            const tMinX = (bounds.minX - origin.x) / rayDir.x;
            const tMaxX = (bounds.maxX - origin.x) / rayDir.x;
            const tMinY = (bounds.minY - origin.y) / rayDir.y;
            const tMaxY = (bounds.maxY - origin.y) / rayDir.y;

            const tMin = Math.max(
                Math.min(tMinX, tMaxX),
                Math.min(tMinY, tMaxY)
            );
            const tMax = Math.min(
                Math.max(tMinX, tMaxX),
                Math.max(tMinY, tMaxY)
            );

            // Check if ray intersects and is in front of origin
            if (tMax >= tMin && tMax > 0 && tMin < closestDistance) {
                const distance = tMin > 0 ? tMin : tMax;
                if (distance < closestDistance && distance > 1) { // Minimum distance of 1mm
                    closestDistance = distance;
                    closestComponent = component;
                }
            }
        }

        return closestComponent ? { component: closestComponent, distance: closestDistance } : null;
    }

    /**
     * Toggle laser on/off (keyboard shortcut)
     */
    toggleLaser() {
        const state = this.store.getState();
        const newState = !state.ui.autoPropagate;

        // Update the checkbox UI
        const checkbox = document.getElementById('auto-propagate-beams');
        if (checkbox) {
            checkbox.checked = newState;
        }

        // Dispatch the toggle action
        this.store.dispatch(actions.toggleAutoPropagate());

        // Propagate or clear beams based on new state
        if (newState) {
            // Turning laser on - propagate all beams from sources
            this.propagateAllBeams();
        } else {
            // Turning laser off - remove all beams
            this.clearAllBeams();
        }
    }

    /**
     * Clear all beam segments (when laser is turned off)
     */
    clearAllBeams() {
        const state = this.store.getState();
        const allSegmentIds = Array.from(state.beamPath.segments.keys());

        // Delete all segments
        for (const segmentId of allSegmentIds) {
            this.store.dispatch(actions.deleteBeamSegment(segmentId));
        }

        console.log('Cleared all beams (laser off)');
    }

    /**
     * Propagate all beams automatically from all components
     */
    propagateAllBeams() {
        const state = this.store.getState();
        const processed = new Set(); // Track processed outputs to avoid duplicates

        // Find all source components and start propagation from them
        for (const [id, component] of state.components) {
            if (component.type === ComponentType.SOURCE && component.emitLight !== false) {
                this.propagateBeamFrom(component.id, null, processed);
            }
        }
    }

    /**
     * Propagate beam from a specific component
     * @param {string} componentId - Starting component ID
     * @param {number|null} incomingAngle - Incoming beam angle (null for sources)
     * @param {Set} processed - Set of processed component:port pairs
     */
    propagateBeamFrom(componentId, incomingAngle, processed) {
        // Get output ports for this component
        let component = this.store.getState().components.get(componentId);
        if (!component) return;

        // Determine output ports based on component type and reflectance
        let outputPorts = [];
        if (component.type === ComponentType.BEAM_SPLITTER) {
            // Only create beams based on reflectance/transmittance values
            const reflectance = component.reflectance ?? 0.5;
            const transmittance = component.transmittance ?? (1 - reflectance);

            if (reflectance > 0) {
                outputPorts.push('reflected');
            }
            if (transmittance > 0) {
                outputPorts.push('transmitted');
            }
        } else if (component.canOutputBeam()) {
            outputPorts = ['output'];
        }

        for (const sourcePort of outputPorts) {
            // Get fresh state for each port iteration
            const state = this.store.getState();
            component = state.components.get(componentId);
            if (!component) continue;

            const portKey = `${componentId}:${sourcePort}`;

            // Skip if already processed
            if (processed.has(portKey)) continue;
            processed.add(portKey);

            // Check if segment already exists for this output
            const existingSegments = state.beamPath.getOutgoingSegments(componentId);
            const hasSegmentForPort = existingSegments.some(seg => seg.sourcePort === sourcePort);
            if (hasSegmentForPort) {
                // Continue propagation from existing target
                const existingSegment = existingSegments.find(seg => seg.sourcePort === sourcePort);
                const targetComp = state.components.get(existingSegment.targetId);
                if (targetComp && targetComp.canOutputBeam()) {
                    const beamAngle = BeamPhysics.calculateBeamAngle(component.position, targetComp.position);
                    this.propagateBeamFrom(targetComp.id, beamAngle, processed);
                }
                continue;
            }

            // Calculate output direction
            const outputAngle = BeamPhysics.getOutputDirection(component, incomingAngle, sourcePort);
            if (outputAngle === null) continue;

            // Find max distance to workspace boundary
            const workspace = state.constraints.workspace;
            const maxDist = Math.max(workspace.width, workspace.height) * 2;

            // Find first component in beam path
            const intersection = this.findRayComponentIntersection(
                component.position,
                outputAngle,
                componentId,
                maxDist
            );

            let segmentCreated = false;

            if (intersection) {
                const targetComponent = intersection.component;

                // Validate connection using physics
                const validation = BeamPhysics.validateConnection(
                    component,
                    targetComponent,
                    sourcePort,
                    incomingAngle,
                    state.components
                );

                if (validation.valid) {
                    // Create segment to the component
                    const segment = new BeamSegment({
                        sourceId: component.id,
                        targetId: targetComponent.id,
                        sourcePort,
                        targetPort: 'input',
                        direction: validation.beamDirection,
                        directionAngle: validation.beamAngle,
                        isValid: true,
                        wavelengthIds: state.activeWavelengthId ? [state.activeWavelengthId] : []
                    });

                    this.store.dispatch(actions.addBeamSegment(segment));
                    console.log(`Laser beam: ${component.name} -> ${targetComponent.name}`);
                    segmentCreated = true;

                    // Continue propagation if target is NOT a detector
                    if (targetComponent.type !== ComponentType.DETECTOR && targetComponent.canOutputBeam()) {
                        this.propagateBeamFrom(targetComponent.id, validation.beamAngle, processed);
                    }
                }
            }

            // If no valid component hit, create beam to workspace boundary
            if (!segmentCreated) {
                const boundaryPoint = this.findWorkspaceBoundaryIntersection(
                    component.position,
                    outputAngle,
                    state.constraints.workspace
                );

                const beamDir = BeamPhysics.angleToVector(outputAngle);
                const segment = new BeamSegment({
                    sourceId: component.id,
                    targetId: null, // No target component
                    endPoint: boundaryPoint, // Explicit endpoint
                    sourcePort,
                    targetPort: 'boundary',
                    direction: beamDir,
                    directionAngle: outputAngle,
                    isValid: true,
                    wavelengthIds: state.activeWavelengthId ? [state.activeWavelengthId] : []
                });

                this.store.dispatch(actions.addBeamSegment(segment));
                console.log(`Laser beam: ${component.name} -> workspace boundary`);
            }
        }
    }
}

// Initialize app when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
    window.app = new BeamPathOptimizerApp();
});

export default BeamPathOptimizerApp;
